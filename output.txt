----- tauri.conf.json -----
{
  "identifier": "cz.lynx.accounting",
  "productName": "accounting",
  "version": "0.0.0",
  "build": {
    "beforeDevCommand": "bun run dev",
    "beforeBuildCommand": "bun run build",
    "devUrl": "http://localhost:1420",
    "frontendDist": "../dist"
  },
  "plugins": {
    "http": {
      "scope": "https://*"
    }
  },

  "bundle": {
    "active": true,
    "targets": "all",
    "licenseFile": "../LICENSE",
    "category": "Utility",
    "publisher": "Lynx",
    "linux": {
      "appimage": {
        "bundleMediaFramework": true,
        "files": {}
      },
      "deb": {
        "files": {}
      },
      "rpm": {
        "epoch": 0,
        "files": {},
        "release": "1"
      }
    },
    "macOS": {
      "dmg": {
        "appPosition": {
          "x": 180,
          "y": 170
        },
        "applicationFolderPosition": {
          "x": 480,
          "y": 170
        },
        "windowSize": {
          "height": 400,
          "width": 660
        }
      },
      "files": {},
      "minimumSystemVersion": "10.15"
    },
    "windows": {
      "allowDowngrades": true,
      "certificateThumbprint": null,
      "digestAlgorithm": "sha256",
      "nsis": null,
      "timestampUrl": null,
      "tsp": false,
      "webviewFixedRuntimePath": null,
      "webviewInstallMode": {
        "silent": true,
        "type": "downloadBootstrapper"
      },
      "wix": null
    },
    "icon": ["icons/32x32.png", "icons/128x128.png", "icons/128x128@2x.png", "icons/icon.icns", "icons/icon.ico"]
  },
  "app": {
    "macOSPrivateApi": true,
    "withGlobalTauri": true,
    "security": {
      "csp": null,
      "assetProtocol": {
        "enable": true,
        "scope": [
          "$APPDATA/*",
          "$DATA/*",
          "$LOCALDATA/*",
          "$DESKTOP/*",
          "$DOCUMENT/*",
          "$DOWNLOAD/*",
          "$HOME/*",
          "$PICTURE/*",
          "$PUBLIC/*",
          "$VIDEO/*",
          "$APPCONFIG/*",
          "$RESOURCE/*"
        ]
      }
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "accounting",
        "width": 900,
        "height": 600,
        "minWidth": 800,
        "minHeight": 550,
        "transparent": true,
        "titleBarStyle": "Overlay",
        "hiddenTitle": true
      }
    ]
  }
}


----- prisma/schema.prisma -----
datasource db {
    provider = "sqlite"
    url      = "file:../app.db"
}

generator client {
    provider    = "cargo prisma"
    output      = "../src/prisma.rs"
    module_path = "crate::db"
}

model Company {
    id        Int        @id @default(autoincrement())
    name      String
    documents Document[]
    templates Template[]
    clients   Client[]
    settings  Settings?

    cin   String  @unique // IČO
    vatId String? @unique // DIČ

    // Adress
    address String
    city    String
    zip     String

    // Additional fields
    phone String?
    email String?
    web   String?

    // Bank account
    bankAccount String?
    bankCode    String?
    bankName    String?
    bankIBAN    String?

    // Document counter and info
    invoicePrefix  String @default("I")
    invoiceCounter Int    @default(1)

    proformaPrefix  String @default("P")
    proformaCounter Int    @default(1)

    recievePrefix  String @default("R")
    recieveCounter Int    @default(1)
}

model Client {
    id         Int    @id @default(autoincrement())
    clientType String @default("BOTH") // ENUM = SUPPLIER, CUSTOMER, BOTH

    name  String
    cin   String  @unique // IČO
    vatId String?

    address String
    city    String
    zip     String

    //Contact info
    email String?
    phone String?

    documents Document[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Document {
    id           Int    @id @default(autoincrement())
    number       String @unique
    documentType String // ENUM = INVOICE, PROFORMA, RECIEVE

    client   Client @relation(fields: [clientId], references: [id])
    clientId Int

    template   Template @relation(fields: [templateId], references: [id])
    templateId Int

    currency String

    issueDate DateTime
    taxDate   DateTime // Datum zdanitelného plnění
    dueDate   DateTime

    status String         @default("DRAFT") // ENUM = DRAFT, PENDING, PAID, CANCELLED, OVERDUE
    items  DocumentItem[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Template {
    id Int @id @default(autoincrement())

    name         String
    html         String
    templateType String     @default("INVOICE") // ENUM = INVOICE, CREDIT_NOTE todo!
    documents    Document[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model DocumentItem {
    id Int @id @default(autoincrement())

    document   Document @relation(fields: [documentId], references: [id])
    documentId Int

    description String
    quantity    Int
    price       Float
    tax         Float
}

model Settings {
    id Int @id @default(autoincrement())

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int     @unique

    currency String
    tax      Float
}


----- prisma-cli/src/main.rs -----
fn main() {
    prisma_client_rust_cli::run();
}


----- build.rs -----
fn main() {
  tauri_build::build()
}


----- src/types.rs -----
use serde::Deserialize;

#[derive(Deserialize, Debug)]
pub struct Indicies {
    pub skip: i64,
    pub take: i64,
}


----- src/util.rs -----
use std::path::PathBuf;

/// Get the accoubting config directory.
/// This config directory has the following structure:
/// - data.db
/// - assets/ # All the images/videos/audios are stored here
/// - config.toml
pub fn get_app_dir() -> PathBuf {
    // get app dir with /accounting. use std libary
    let path = platform_dirs::AppDirs::new(Some("accounting"), true).unwrap();
    let mut data_dir = path.data_dir;

    // check if in dev mode
    if cfg!(debug_assertions) {
        // set the dir to ./
        data_dir = PathBuf::from("./");
    }

    data_dir
}


----- src/error.rs -----
use prisma_client_rust::migrations::DbPushError;
use serde::{Serialize, Serializer};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum CoreError {
    #[error("Prisma New Client Error")]
    PrismaNewClientError(#[from] prisma_client_rust::NewClientError),

    #[error("Prisma Query Error")]
    PrismaQueryError(#[from] prisma_client_rust::QueryError),

    #[error("Tokio IO Error")]
    TokioError(#[from] tokio::io::Error),

    #[error("Tokio Join Error")]
    TokioJoinError(#[from] tokio::task::JoinError),

    #[error("Db Push Error")]
    DbPushError(#[from] DbPushError),
}

impl Serialize for CoreError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.to_string().as_ref())
    }
}

pub type CommandResult<T, E = CoreError> = anyhow::Result<T, E>;


----- src/main.rs -----
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

extern crate pretty_env_logger;
#[macro_use]
extern crate log;

#[cfg(target_os = "macos")]
extern crate objc;

#[cfg(target_os = "macos")]
mod window_ext;

#[allow(warnings, unused)]
mod prisma;

mod commands;
mod error;
mod migrator;
mod types;
mod util;

use migrator::new_client;
use prisma::*;
use std::sync::Arc;
use tauri::{Manager, State};
use tauri_plugin_autostart::MacosLauncher;
use window_ext::{ToolbarThickness, WindowExt};
use window_vibrancy::NSVisualEffectMaterial;

#[cfg(target_os = "windows")]
use window_vibrancy::apply_mica;
#[cfg(target_os = "macos")]
use window_vibrancy::apply_vibrancy;

#[derive(Clone, serde::Serialize)]
struct Payload {
    args: Vec<String>,
    cwd: String,
}

type DbState<'a> = State<'a, Arc<PrismaClient>>;

#[tokio::main]
async fn main() {
    std::env::set_var("RUST_LOG", "trace");
    pretty_env_logger::init();

    let client = new_client().await.unwrap();

    // let specta_builder = {
    //     let specta_builder = tauri_specta::ts::builder().commands(tauri_specta::collect_commands![
    //         get_company,
    //         create_company,
    //         migrate_and_populate,
    //         check_db
    //     ]);

    //     #[cfg(debug_assertions)] // <- Only export on non-release builds
    //     let specta_builder = specta_builder.path("../src/bindings.ts");

    //     specta_builder.into_plugin()
    // };

    tauri::Builder::default()
        .plugin(tauri_plugin_autostart::init(
            MacosLauncher::LaunchAgent,
            Some(vec!["--flag1", "--flag2"]),
        ))
        .plugin(tauri_plugin_single_instance::init(|app, argv, cwd| {
            println!("{}, {argv:?}, {cwd}", app.package_info().name);
            app.emit("single-instance", Payload { args: argv, cwd })
                .unwrap();
        }))
        // .plugin(specta_builder)
        // .plugin(tauri_plugin_updater::Builder::new().build())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_clipboard_manager::init())
        .plugin(tauri_plugin_process::init())
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_os::init())
        .plugin(tauri_plugin_store::Builder::default().build())
        .setup(|app| {
            let window = app.get_webview_window("main").unwrap();
            window.set_thickness(ToolbarThickness::Thick);

            #[cfg(target_os = "macos")]
            apply_vibrancy(&window, NSVisualEffectMaterial::HudWindow, None, None)
                .expect("Unsupported platform! 'apply_vibrancy' is only supported on macOS");

            #[cfg(target_os = "windows")]
            apply_mica(&window, Some(true))
                .expect("Unsupported platform! 'apply_mica' is only supported on Windows");

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::db::check_db,
            commands::db::migrate_and_populate,
            commands::company::get_company,
            commands::company::create_company,
            commands::company::get_companies,
            commands::document::get_documents,
            commands::document::get_document,
            commands::document::create_document,
            commands::document::update_document,
            commands::document::delete_document,
            commands::template::get_templates,
            commands::template::get_template,
            commands::template::create_template,
            commands::template::update_template,
            commands::template::delete_template,
            commands::template::template_count,
            commands::client::get_clients,
            commands::client::get_client,
            commands::client::update_client,
            commands::client::create_client,
            commands::client::delete_client,
        ])
        .manage(Arc::new(client))
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}


----- src/migrator.rs -----
use log::info;

use crate::{
    error::CoreError,
    prisma::{_prisma::PrismaClient, new_client_with_url},
    util::get_app_dir,
};

pub async fn new_client() -> Result<PrismaClient, CoreError> {
    let appdata_url = get_app_dir().join("app.db");

    log::info!("Connecting to database at {}", appdata_url.display());

    tokio::fs::create_dir_all(appdata_url.parent().unwrap()).await?;

    if !appdata_url.exists() {
        tokio::fs::File::create(appdata_url.clone()).await?;
        info!("Created database at {}", appdata_url.display());
    }

    let client =
        new_client_with_url(&("file:".to_string() + appdata_url.to_str().unwrap())).await?;

    Ok(client)
}


----- src/commands/other.rs -----
use crate::template;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[derive(Deserialize, Debug)]
pub struct Indicies {
    skip: i64,
    take: i64,
}

#[tauri::command]
pub async fn get_templates(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<template::Data>, QueryError> {
    debug!("Getting templates");
    let data = client
        .template()
        .find_many(vec![template::company_id::equals(company_id)])
        .skip(0)
        .take(100)
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_template(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<template::Data>, QueryError> {
    client
        .template()
        .find_unique(template::id::equals(id))
        .exec()
        .await
}

// #[derive(Debug)]
// pub enum TemplateType {
//     Invoice,
//     Estimate,
//     Receipt,
// }

// #[derive(Deserialize, Debug)]
// pub struct CreateTemplateData {
//     html: String,
//     company_id: i32,
//     template_type: TemplateType,
// }

// #[tauri::command]
// pub async fn create_template(
//     client: DbState<'_>,
//     data: CreateTemplateData,
// ) -> Result<template::Data, QueryError> {
//     debug!("Creating template {:?}", data);
//     client
//         .template()
//         .create(data.html, data.template_type, data.company_id)
//         .exec()
//         .await
// }


----- src/commands/client.rs -----
use crate::client;
use crate::company;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_clients(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<client::Data>, QueryError> {
    debug!(
        "Getting clients from {} with indicies {:?}",
        company_id, indicies
    );
    client
        .client()
        .find_many(vec![client::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await
}

#[tauri::command]
pub async fn get_client(client: DbState<'_>, id: i32) -> Result<Option<client::Data>, QueryError> {
    client
        .client()
        .find_unique(client::id::equals(id))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Creating client");
    let data = client
        .client()
        .create(
            data.name,
            data.cin,
            data.address,
            data.city,
            data.zip,
            company::id::equals(data.company_id),
            vec![
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Updating client");
    let data = client
        .client()
        .update(
            client::id::equals(data.id),
            vec![
                client::name::set(data.name),
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::cin::set(data.cin),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
                client::address::set(data.address),
                client::city::set(data.city),
                client::zip::set(data.zip),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_client(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting client");
    let data = client.client().delete(client::id::equals(id)).exec().await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src/commands/company.rs -----
use crate::company;
use crate::DbState;
use prisma_client_rust::not;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_companies(
    client: DbState<'_>,
    exclude: Option<i32>,
) -> Result<Vec<company::Data>, QueryError> {
    println!("Getting companies, exluding {:?}", exclude);
    let data = client
        .company()
        .find_many(vec![not![company::id::equals(exclude.unwrap_or(999))]])
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_company(
    client: DbState<'_>,
    id: Option<i32>,
) -> Result<Option<company::Data>, QueryError> {
    client
        .company()
        .find_first(vec![company::id::equals(id.unwrap_or(1))])
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
pub struct CreateCompanyData {
    name: String,
    cin: String,
    vat_id: Option<String>,
    // street_adress: String,
    city: String,
    // postal_code: String,
    phone_number: Option<String>,
    email: Option<String>,
}

#[tauri::command]
pub async fn create_company(
    client: DbState<'_>,
    data: CreateCompanyData,
) -> Result<company::Data, ()> {
    debug!("Creating company {:?}", data);
    client
        .company()
        .create(
            data.name,
            data.cin,
            "cus".to_string(),
            data.city,
            "aaaa".to_string(),
            vec![
                company::vat_id::set(data.vat_id),
                company::phone::set(data.phone_number),
            ],
        )
        .exec()
        .await
        .map_err(|_| ())
}


----- src/commands/db.rs -----
use crate::error::CommandResult;
// use crate::migrator::new_client;
use crate::DbState;

// #[specta::specta]
#[tauri::command]
pub async fn check_db(client: DbState<'_>) -> CommandResult<i16> {
    let company_count = client.company().count(vec![]).exec().await;

    info!("Checking DB");
    match company_count {
        Ok(_) => {
            if company_count.unwrap() == 0 {
                return Ok(400);
            }
            return Ok(200);
        }
        Err(_) => Ok(400),
    }
}

// #[specta::specta]
#[tauri::command]
pub async fn migrate_and_populate(client: DbState<'_>) -> CommandResult<()> {
    #[cfg(debug_assertions)]
    client._db_push().await?;

    #[cfg(not(debug_assertions))]
    client._migrate_deploy().await.unwrap();

    Ok(())
}


----- src/commands/mod.rs -----
pub mod client;
pub mod company;
pub mod db;
pub mod document;
pub mod template;


----- src/commands/document.rs -----
use crate::client;
use crate::company;
use crate::document;
use crate::template;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_documents(
    client: DbState<'_>,
    company_id: i32,
    document_type: String,
    indicies: Indicies,
) -> Result<Vec<document::Data>, QueryError> {
    debug!(
        "Getting documents from {} with type {} and indicies {:?}",
        company_id, document_type, indicies
    );
    client
        .document()
        .find_many(vec![
            document::company_id::equals(company_id),
            document::document_type::equals(document_type),
        ])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await
}

#[tauri::command]
pub async fn get_document(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<document::Data>, QueryError> {
    client
        .document()
        .find_unique(document::id::equals(id))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Creating document");
    let data = client
        .document()
        .create(
            data.number,
            data.document_type,
            client::id::equals(data.client_id),
            template::id::equals(data.template_id),
            data.currency,
            data.issue_date,
            data.tax_date,
            data.due_date,
            company::id::equals(data.company_id),
            vec![document::status::set(data.status)],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Updating document");
    let data = client
        .document()
        .update(
            document::id::equals(data.id),
            vec![
                document::number::set(data.number),
                document::document_type::set(data.document_type),
                document::client_id::set(data.client_id),
                document::template_id::set(data.template_id),
                document::currency::set(data.currency),
                document::issue_date::set(data.issue_date),
                document::tax_date::set(data.tax_date),
                document::due_date::set(data.due_date),
                document::status::set(data.status),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_document(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting document");
    let data = client
        .document()
        .delete(document::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src/commands/template.rs -----
use crate::company;
use crate::template;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_templates(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<template::Data>, QueryError> {
    debug!("Getting templates");
    let data = client
        .template()
        .find_many(vec![template::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_template(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<template::Data>, QueryError> {
    client
        .template()
        .find_unique(template::id::equals(id))
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CreateTemplateData {
    html: String,
    name: String,
    template_type: String,
}
#[tauri::command]
pub async fn create_template(
    client: DbState<'_>,
    company_id: i32,
    data: CreateTemplateData,
) -> Result<(), String> {
    debug!("Creating template");
    let data = client
        .template()
        .create(
            data.name,
            data.html,
            company::id::equals(company_id),
            vec![template::template_type::set(data.template_type)],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_template(client: DbState<'_>, id: i32, html: String) -> Result<(), String> {
    debug!("Updating template");
    let data = client
        .template()
        .update(template::id::equals(id), vec![template::html::set(html)])
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

// #[derive(Debug)]
// pub enum TemplateType {
//     Invoice,
//     Estimate,
//     Receipt,
// }

// #[tauri::command]
// pub async fn create_template(
//     client: DbState<'_>,
//     data: CreateTemplateData,
// ) -> Result<template::Data, QueryError> {
//     debug!("Creating template {:?}", data);
//     client
//         .template()
//         .create(data.html, data.template_type, data.company_id)
//         .exec()
//         .await
// }

#[tauri::command]
pub async fn delete_template(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting template");
    let data = client
        .template()
        .delete(template::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn template_count(client: DbState<'_>, company_id: i32) -> Result<i64, QueryError> {
    debug!("Getting template count");
    client
        .template()
        .count(vec![template::company_id::equals(company_id)])
        .exec()
        .await
}


----- src/window_ext.rs -----
use tauri::{Runtime, WebviewWindow};

#[allow(dead_code)]
pub enum ToolbarThickness {
    Thick,
    Medium,
    Thin,
}

pub trait WindowExt {
    #[cfg(target_os = "macos")]
    fn set_thickness(&self, thickness: ToolbarThickness);
}

impl<R: Runtime> WindowExt for WebviewWindow<R> {
    #[cfg(target_os = "macos")]
    fn set_thickness(&self, thickness: ToolbarThickness) {
        unsafe {
            let id = self.ns_window().unwrap() as cocoa::base::id;

            match thickness {
                ToolbarThickness::Thick => {
                    self.set_title("").expect("Title wasn't set to ''");
                    make_toolbar(id);
                }
                ToolbarThickness::Medium => {
                    make_toolbar(id);
                }
                ToolbarThickness::Thin => {
                    // todo
                }
            }
        }
    }
}

#[cfg(target_os = "macos")]
unsafe fn make_toolbar(id: cocoa::base::id) {
    use cocoa::appkit::{NSToolbar, NSWindow};

    let new_toolbar = NSToolbar::alloc(id);
    new_toolbar.init_();
    id.setToolbar_(new_toolbar);
}


