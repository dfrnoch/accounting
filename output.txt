
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"

----- tauri.conf.json -----
{
  "identifier": "cz.lynx.accounting",
  "productName": "accounting",
  "version": "0.0.0",
  "build": {
    "beforeDevCommand": "bun run dev",
    "beforeBuildCommand": "bun run build",
    "devUrl": "http://localhost:1420",
    "frontendDist": "../dist"
  },
  "plugins": {
    "http": {
      "scope": "https://*"
    }
  },

  "bundle": {
    "active": true,
    "targets": "all",
    "licenseFile": "../LICENSE",
    "category": "Utility",
    "publisher": "Lynx",
    "linux": {
      "appimage": {
        "bundleMediaFramework": true,
        "files": {}
      },
      "deb": {
        "files": {}
      },
      "rpm": {
        "epoch": 0,
        "files": {},
        "release": "1"
      }
    },
    "macOS": {
      "dmg": {
        "appPosition": {
          "x": 180,
          "y": 170
        },
        "applicationFolderPosition": {
          "x": 480,
          "y": 170
        },
        "windowSize": {
          "height": 400,
          "width": 660
        }
      },
      "files": {},
      "minimumSystemVersion": "10.15"
    },
    "windows": {
      "allowDowngrades": true,
      "certificateThumbprint": null,
      "digestAlgorithm": "sha256",
      "nsis": null,
      "timestampUrl": null,
      "tsp": false,
      "webviewFixedRuntimePath": null,
      "webviewInstallMode": {
        "silent": true,
        "type": "downloadBootstrapper"
      },
      "wix": null
    },
    "icon": ["icons/32x32.png", "icons/128x128.png", "icons/128x128@2x.png", "icons/icon.icns", "icons/icon.ico"]
  },
  "app": {
    "macOSPrivateApi": true,
    "withGlobalTauri": true,
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "Accounting",
        "width": 900,
        "height": 600,
        "minWidth": 800,
        "minHeight": 550,
        "transparent": true,
        "titleBarStyle": "Overlay",
        "hiddenTitle": true
      }
    ]
  }
}


----- prisma/schema.prisma -----
datasource db {
    provider = "sqlite"
    url      = "file:../app.db"
}

generator client {
    provider    = "cargo prisma"
    output      = "../src/prisma.rs"
    module_path = "crate::db"
}

model Company {
    id         Int        @id @default(autoincrement())
    name       String
    documents  Document[]
    templates  Template[]
    currencies Currency[]
    clients    Client[]
    settings   Settings?

    cin   String  @unique // IČO
    vatId String? @unique // DIČ

    // Adress
    address String
    city    String
    zip     String

    // Additional fields
    phone String?
    email String?
    web   String?

    // Bank account
    bankAccount String?
    bankIban    String?
}

model Client {
    id         Int    @id @default(autoincrement())
    clientType String @default("BOTH") // ENUM = SUPPLIER, CUSTOMER, BOTH

    name  String
    cin   String  @unique // IČO
    vatId String?

    address String
    city    String
    zip     String

    //Contact info
    email String?
    phone String?

    bankAccount String?
    bankCode    String?
    bankName    String?
    bankIban    String?

    documents Document[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Document {
    id           Int    @id @default(autoincrement())
    number       String @unique
    documentType String // ENUM = INVOICE, PROFORMA, RECEIVE

    client   Client @relation(fields: [clientId], references: [id])
    clientId Int

    template   Template @relation(fields: [templateId], references: [id])
    templateId Int

    currency   Currency @relation(fields: [currencyId], references: [id])
    currencyId String

    issueDate DateTime
    // taxDate   DateTime // Datum zdanitelného plnění
    dueDate   DateTime

    status String         @default("DRAFT") // ENUM = DRAFT, PENDING, PAID, CANCELLED, OVERDUE
    items  DocumentItem[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Template {
    id Int @id @default(autoincrement())

    name         String
    html         String
    templateType String     @default("INVOICE") // ENUM = INVOICE, CREDIT_NOTE todo!
    documents    Document[]

    company   Company    @relation(fields: [companyId], references: [id])
    companyId Int
    Settings  Settings[]
}

model DocumentItem {
    id Int @id @default(autoincrement())

    document   Document @relation(fields: [documentId], references: [id])
    documentId Int

    description String
    quantity    Int
    price       Float
    // tax         Float
}

model Settings {
    id Int @id @default(autoincrement())

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int     @unique

    defaultCurrency   Currency @relation(fields: [defaultCurrencyId], references: [id])
    defaultCurrencyId String

    defaultTemplate   Template @relation(fields: [defaultTemplateId], references: [id])
    defaultTemplateId Int
    // tax               Float

    invoicePrefix  String @default("I202400000")
    invoiceCounter Int    @default(1)

    proformaPrefix  String @default("P")
    proformaCounter Int    @default(1)

    receivePrefix  String @default("R")
    receiveCounter Int    @default(1)
}

model Currency {
    id String @id @default(cuid())

    name String
    code String
    rate Float //Rate To EURO

    company   Company    @relation(fields: [companyId], references: [id])
    companyId Int
    documents Document[]

    settings Settings[]
}


----- prisma-cli/src/main.rs -----
fn main() {
    prisma_client_rust_cli::run();
}


----- build.rs -----
fn main() {
  tauri_build::build()
}


----- src/types.rs -----
use serde::Deserialize;

#[derive(Deserialize, Debug)]
pub struct Indicies {
    pub skip: i64,
    pub take: i64,
}


----- src/util.rs -----
use std::path::PathBuf;

/// Get the accoubting config directory.
/// This config directory has the following structure:
/// - data.db
/// - assets/ # All the images/videos/audios are stored here
/// - config.toml
pub fn get_app_dir() -> PathBuf {
    // get app dir with /accounting. use std libary
    let path = platform_dirs::AppDirs::new(Some("accounting"), true).unwrap();
    let mut data_dir = path.data_dir;

    // check if in dev mode
    if cfg!(debug_assertions) {
        // set the dir to ./
        data_dir = PathBuf::from("./");
    }

    data_dir
}


----- src/error.rs -----
use prisma_client_rust::migrations::DbPushError;
use serde::{Serialize, Serializer};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum CoreError {
    #[error("Prisma New Client Error")]
    PrismaNewClientError(#[from] prisma_client_rust::NewClientError),

    #[error("Prisma Query Error")]
    PrismaQueryError(#[from] prisma_client_rust::QueryError),

    #[error("Tokio IO Error")]
    TokioError(#[from] tokio::io::Error),

    #[error("Tokio Join Error")]
    TokioJoinError(#[from] tokio::task::JoinError),

    #[error("Db Push Error")]
    DbPushError(#[from] DbPushError),
}

impl Serialize for CoreError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.to_string().as_ref())
    }
}

pub type CommandResult<T, E = CoreError> = anyhow::Result<T, E>;


----- src/main.rs -----
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

extern crate pretty_env_logger;
#[macro_use]
extern crate log;

#[cfg(target_os = "macos")]
extern crate objc;

#[cfg(target_os = "macos")]
mod window_ext;

#[allow(warnings, unused)]
mod prisma;

mod commands;
mod error;
mod migrator;
mod types;
mod util;

use migrator::new_client;
use prisma::*;
use std::sync::Arc;
use tauri::{Manager, State};

#[cfg(target_os = "macos")]
use window_ext::{ToolbarThickness, WindowExt};
#[cfg(target_os = "macos")]
use window_vibrancy::NSVisualEffectMaterial;

#[cfg(target_os = "windows")]
use window_vibrancy::apply_mica;
#[cfg(target_os = "macos")]
use window_vibrancy::apply_vibrancy;

#[derive(Clone, serde::Serialize)]
struct Payload {
    args: Vec<String>,
    cwd: String,
}

type DbState<'a> = State<'a, Arc<PrismaClient>>;

#[tokio::main]
async fn main() {
    std::env::set_var("RUST_LOG", "trace");
    pretty_env_logger::init();

    let client = new_client().await.unwrap();

    tauri::Builder::default()
        .plugin(tauri_plugin_single_instance::init(|app, argv, cwd| {
            println!("{}, {argv:?}, {cwd}", app.package_info().name);
            app.emit("single-instance", Payload { args: argv, cwd })
                .unwrap();
        }))
        // .plugin(tauri_plugin_updater::Builder::new().build())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_os::init())
        .setup(|app| {
            let window = app.get_webview_window("main").unwrap();

            #[cfg(target_os = "macos")]
            window.set_thickness(ToolbarThickness::Thick);

            #[cfg(target_os = "macos")]
            apply_vibrancy(&window, NSVisualEffectMaterial::HudWindow, None, None)
                .expect("Unsupported platform! 'apply_vibrancy' is only supported on macOS");

            #[cfg(target_os = "windows")]
            apply_mica(&window, Some(true))
                .expect("Unsupported platform! 'apply_mica' is only supported on Windows");

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::db::check_db,
            commands::db::migrate_and_populate,
            commands::company::get_company,
            commands::company::create_company,
            commands::company::get_companies,
            commands::company::update_company,
            commands::document::get_documents,
            commands::document::get_document,
            commands::document::create_document,
            commands::document::get_document_count,
            commands::document::update_document,
            commands::document::delete_document,
            commands::template::get_templates,
            commands::template::get_template,
            commands::template::create_template,
            commands::template::update_template,
            commands::template::delete_template,
            commands::client::get_clients,
            commands::client::get_client,
            commands::client::update_client,
            commands::client::create_client,
            commands::client::delete_client,
            commands::stats::get_sales,
            commands::stats::get_expenses,
            commands::stats::get_documents_stats,
            commands::stats::get_sales_and_expenses,
            commands::other::get_model_count,
            commands::other::get_print_document,
            commands::currency::get_currencies,
            commands::currency::get_currency,
            commands::currency::create_currency,
            commands::currency::update_currency,
            commands::currency::delete_currency,
            commands::settings::get_settings,
            commands::settings::update_settings
        ])
        .manage(Arc::new(client))
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}


----- src/migrator.rs -----
use log::info;

use crate::{
    error::CoreError,
    prisma::{_prisma::PrismaClient, new_client_with_url},
    util::get_app_dir,
};

pub async fn new_client() -> Result<PrismaClient, CoreError> {
    let appdata_url = get_app_dir().join("app.db");

    log::info!("Connecting to database at {}", appdata_url.display());

    tokio::fs::create_dir_all(appdata_url.parent().unwrap()).await?;

    if !appdata_url.exists() {
        tokio::fs::File::create(appdata_url.clone()).await?;
        info!("Created database at {}", appdata_url.display());
    }

    let client =
        new_client_with_url(&("file:".to_string() + appdata_url.to_str().unwrap())).await?;

    Ok(client)
}


----- src/commands/other.rs -----
use crate::client;
use crate::company;
use crate::currency;
use crate::document;
use crate::template;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_model_count(
    client: DbState<'_>,
    company_id: i32,
    model: String,
) -> Result<i64, String> {
    match model.as_str() {
        "Invoice" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("INVOICE".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting invoices: {}", e)),
        "Proforma" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("PROFORMA".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting proformas: {}", e)),
        "Receive" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("RECEIVE".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting received invoices: {}", e)),
        "Company" => client
            .company()
            .count(vec![company::id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting companies: {}", e)),
        "Client" => client
            .client()
            .count(vec![client::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting clients: {}", e)),
        "Template" => client
            .template()
            .count(vec![template::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting templates: {}", e)),
        "Currency" => client
            .currency()
            .count(vec![currency::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting currencies: {}", e)),
        _ => Err("Model not found".to_string()),
    }
}

#[tauri::command]
pub async fn get_print_document(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<document::Data>, QueryError> {
    client
        .document()
        .find_unique(document::id::equals(id))
        .with(document::items::fetch(vec![]))
        .with(document::currency::fetch())
        .with(document::client::fetch())
        .with(document::template::fetch())
        .with(document::company::fetch())
        .exec()
        .await
}


----- src/commands/client.rs -----
use crate::client;
use crate::company;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_clients(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<client::Data>, QueryError> {
    debug!(
        "Getting clients from {} with indicies {:?}",
        company_id, indicies
    );
    client
        .client()
        .find_many(vec![client::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await
}

#[tauri::command]
pub async fn get_client(client: DbState<'_>, id: i32) -> Result<Option<client::Data>, QueryError> {
    client
        .client()
        .find_unique(client::id::equals(id))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Creating client");
    let data = client
        .client()
        .create(
            data.name,
            data.cin,
            data.address,
            data.city,
            data.zip,
            company::id::equals(data.company_id),
            vec![
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Updating client");
    let data = client
        .client()
        .update(
            client::id::equals(data.id),
            vec![
                client::name::set(data.name),
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::cin::set(data.cin),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
                client::address::set(data.address),
                client::city::set(data.city),
                client::zip::set(data.zip),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_client(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting client");
    let data = client.client().delete(client::id::equals(id)).exec().await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src/commands/company.rs -----
use crate::company;
use crate::currency;
use crate::template;
use crate::DbState;
use prisma_client_rust::not;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_companies(
    client: DbState<'_>,
    exclude: Option<i32>,
) -> Result<Vec<company::Data>, QueryError> {
    println!("Getting companies, exluding {:?}", exclude);
    let data = client
        .company()
        .find_many(vec![not![company::id::equals(exclude.unwrap_or(999))]])
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_company(
    client: DbState<'_>,
    id: Option<i32>,
) -> Result<Option<company::Data>, QueryError> {
    client
        .company()
        .find_first(vec![company::id::equals(id.unwrap_or(1))])
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ManageCompanyData {
    name: String,
    cin: String,
    vat_id: Option<String>,
    address: String,
    city: String,
    zip: String,
    phone: Option<String>,
    email: Option<String>,

    bank_account: Option<String>,
    bank_iban: Option<String>,
}

#[tauri::command]
pub async fn create_company(
    client: DbState<'_>,
    data: ManageCompanyData,
) -> Result<i32, QueryError> {
    debug!("Creating company {:?}", data);
    let company = client
        .company()
        .create(
            data.name,
            data.cin,
            data.address,
            data.city,
            data.zip,
            vec![
                company::vat_id::set(data.vat_id),
                company::email::set(data.email),
                company::phone::set(data.phone),
                company::bank_account::set(data.bank_account),
                company::bank_iban::set(data.bank_iban),
            ],
        )
        .exec()
        .await
        .unwrap();

    let currency = client
        .currency()
        .create(
            "Euro".to_string(),
            "EUR".to_string(),
            1.0,
            company::id::equals(company.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    let template = client
        .template()
        .create(
            "Default Invoice".to_string(),
            "<html><body><h1>Invoice</h1></body></html>".to_string(),
            company::id::equals(company.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    let _settings = client
        .settings()
        .create(
            company::id::equals(company.id),
            currency::id::equals(currency.id),
            template::id::equals(template.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    Ok(company.id)
}

#[tauri::command]
pub async fn update_company(
    client: DbState<'_>,
    id: i32,
    data: ManageCompanyData,
) -> Result<(), QueryError> {
    debug!("Updating company");
    println!("{:?}", data);
    let data = client
        .company()
        .update(
            company::id::equals(id),
            vec![
                company::name::set(data.name),
                company::cin::set(data.cin),
                company::vat_id::set(data.vat_id),
                company::address::set(data.address),
                company::city::set(data.city),
                company::zip::set(data.zip),
                company::phone::set(data.phone),
                company::email::set(data.email),
                company::bank_account::set(data.bank_account),
                company::bank_iban::set(data.bank_iban),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}


----- src/commands/db.rs -----
use crate::error::CommandResult;
// use crate::migrator::new_client;
use crate::DbState;

// #[specta::specta]
#[tauri::command]
pub async fn check_db(client: DbState<'_>) -> CommandResult<i16> {
    let company_count = client.company().count(vec![]).exec().await;

    info!("Checking DB");
    match company_count {
        Ok(_) => {
            if company_count.unwrap() == 0 {
                return Ok(400);
            }
            return Ok(200);
        }
        Err(_) => Ok(400),
    }
}

// #[specta::specta]
#[tauri::command]
pub async fn migrate_and_populate(client: DbState<'_>) -> CommandResult<()> {
    #[cfg(not(debug_assertions))]
    client._db_push().await?;

    #[cfg(not(debug_assertions))]
    client._migrate_deploy().await.unwrap();

    Ok(())
}


----- src/commands/mod.rs -----
pub mod client;
pub mod company;
pub mod currency;
pub mod db;
pub mod document;
pub mod other;
pub mod settings;
pub mod stats;
pub mod template;


----- src/commands/currency.rs -----
use crate::company;
use crate::currency;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_currencies(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<currency::Data>, QueryError> {
    debug!("Getting currencies");
    let data = client
        .currency()
        .find_many(vec![currency::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_currency(
    client: DbState<'_>,
    id: String,
) -> Result<Option<currency::Data>, QueryError> {
    client
        .currency()
        .find_first(vec![currency::id::equals(id)])
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CurrencyData {
    name: String,
    code: String,
    rate: f64,
}
#[tauri::command]
pub async fn create_currency(
    client: DbState<'_>,
    company_id: i32,
    data: CurrencyData,
) -> Result<(), String> {
    debug!("Creating currency");
    let data = client
        .currency()
        .create(
            data.name,
            data.code,
            data.rate,
            company::id::equals(company_id),
            vec![],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_currency(
    client: DbState<'_>,
    id: String,
    data: CurrencyData,
) -> Result<(), String> {
    debug!("Updating currency");
    let data = client
        .currency()
        .update(
            currency::id::equals(id),
            vec![
                currency::name::set(data.name),
                currency::code::set(data.code),
                currency::rate::set(data.rate),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_currency(client: DbState<'_>, id: String) -> Result<(), String> {
    debug!("Deleting currency");
    let data = client
        .currency()
        .delete(currency::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src/commands/document.rs -----
use crate::client;
use crate::commands::settings::update_count;
use crate::company;
use crate::currency;
use crate::document;
use crate::document_item;
use crate::template;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::chrono::{DateTime, FixedOffset};
use prisma_client_rust::Direction;
use prisma_client_rust::QueryError;

use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct DocumentWithPrice {
    id: i32,
    number: String,
    document_type: String,
    client_id: i32,
    template_id: i32,
    currency: String,
    issue_date: DateTime<FixedOffset>,
    due_date: DateTime<FixedOffset>,
    company_id: i32,
    status: String,
    items: Option<Vec<document_item::Data>>,
    total_price: f64,
}

#[tauri::command]
pub async fn get_documents(
    client: DbState<'_>,
    company_id: i32,
    document_type: Option<String>,
    indicies: Indicies,
    client_id: Option<i32>,
) -> Result<Vec<DocumentWithPrice>, QueryError> {
    debug!(
        "Getting documents from {} with type {:?} and indicies {:?}",
        company_id, document_type, indicies
    );

    let mut conditions = vec![document::company_id::equals(company_id)];

    if let Some(client_id) = client_id {
        conditions.push(document::client_id::equals(client_id));
    }
    if let Some(document_type) = document_type {
        conditions.push(document::document_type::equals(document_type));
    }

    let documents = client
        .document()
        .find_many(conditions)
        .order_by(document::id::order(Direction::Desc))
        .with(document::items::fetch(vec![]))
        .with(document::currency::fetch())
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await?;

    let documents_with_price = documents
        .into_iter()
        .map(|doc| {
            let total_price: f64 = doc
                .items
                .as_ref()
                .unwrap_or(&vec![])
                .iter()
                .map(|item| item.price * item.quantity as f64)
                .sum();
            DocumentWithPrice {
                id: doc.id,
                number: doc.number,
                document_type: doc.document_type,
                client_id: doc.client_id,
                template_id: doc.template_id,
                currency: doc.currency.unwrap().code,
                issue_date: doc.issue_date,
                due_date: doc.due_date,
                company_id: doc.company_id,
                status: doc.status,
                items: doc.items,
                total_price,
            }
        })
        .collect::<Vec<DocumentWithPrice>>();

    Ok(documents_with_price)
}

#[tauri::command]
pub async fn get_document_count(
    client: DbState<'_>,
    document_type: Option<String>,
    client_id: Option<i32>,
) -> Result<i64, QueryError> {
    let mut conditions = vec![];

    if let Some(client_id) = client_id {
        conditions.push(document::client_id::equals(client_id));
    }
    if let Some(document_type) = document_type {
        conditions.push(document::document_type::equals(document_type));
    }

    client.document().count(conditions).exec().await
}

#[tauri::command]
pub async fn get_document(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<document::Data>, QueryError> {
    client
        .document()
        .find_unique(document::id::equals(id))
        .with(document::items::fetch(vec![]))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Creating document");
    let res = client
        .document()
        .create(
            data.number,
            data.document_type,
            client::id::equals(data.client_id),
            template::id::equals(data.template_id),
            currency::id::equals(data.currency_id),
            data.issue_date,
            data.due_date,
            company::id::equals(data.company_id),
            vec![document::status::set(data.status)],
        )
        .exec()
        .await;

    if let Some(items) = data.items {
        for item in items.iter() {
            let _ = client
                .document_item()
                .create(
                    document::id::equals(res.as_ref().unwrap().company_id),
                    item.description.clone(),
                    item.quantity,
                    item.price,
                    vec![],
                )
                .exec()
                .await
                .unwrap();
        }
    }

    match res {
        Ok(_) => {
            update_count(client, data.company_id, "Invoice").await;
            Ok(())
        }
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Updating document");

    // Update the document fields
    let updated_document = client
        .document()
        .update(
            document::id::equals(data.id),
            vec![
                document::number::set(data.number),
                document::document_type::set(data.document_type),
                document::client_id::set(data.client_id),
                document::template_id::set(data.template_id),
                document::currency_id::set(data.currency_id),
                document::issue_date::set(data.issue_date),
                document::due_date::set(data.due_date),
                document::status::set(data.status),
            ],
        )
        .exec()
        .await;

    match updated_document {
        Ok(_) => {
            let _ = client
                .document_item()
                .delete_many(vec![document_item::document_id::equals(data.id)])
                .exec()
                .await;

            if let Some(items) = data.items {
                for item in items.iter() {
                    println!("ITEMS: {:?}", item);
                    let _ = client
                        .document_item()
                        .create(
                            document::id::equals(data.id),
                            item.description.clone(),
                            item.quantity,
                            item.price,
                            vec![],
                        )
                        .exec()
                        .await;
                }
            }

            Ok(())
        }
        Err(e) => {
            error!("Error updating document: {}", e);
            Err(e.to_string())
        }
    }
}

#[tauri::command]
pub async fn delete_document(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting document");
    let data = client
        .document()
        .delete(document::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src/commands/stats.rs -----
use crate::currency;
use crate::document;
use crate::settings;
use crate::DbState;
use prisma_client_rust::chrono::{DateTime, Datelike, Duration, FixedOffset, Local, TimeZone};
use prisma_client_rust::QueryError;

fn get_month_ranges(months: i32) -> Vec<(DateTime<FixedOffset>, DateTime<FixedOffset>)> {
    let today = Local::now();
    let today_naive = today.naive_local().date();
    let mut month_ranges = Vec::new();

    for month_offset in 0..months {
        let target_month = (today_naive.month() as i32 - month_offset - 1).rem_euclid(12) + 1;
        let year_adjustment = (today_naive.month() as i32 - month_offset - 1) / 12;
        let adjusted_year = today_naive.year() + year_adjustment;

        let first_day_of_target_month = today_naive
            .with_year(adjusted_year)
            .unwrap()
            .with_month(target_month as u32)
            .unwrap()
            .with_day(1)
            .unwrap();
        let last_day_of_target_month = first_day_of_target_month
            .with_month((target_month % 12 + 1) as u32)
            .unwrap_or_else(|| {
                first_day_of_target_month
                    .with_year(adjusted_year + 1)
                    .unwrap()
                    .with_month(1)
                    .unwrap()
            })
            - Duration::days(1);

        let start_datetime = FixedOffset::east_opt(0)
            .unwrap()
            .from_utc_datetime(&first_day_of_target_month.and_hms_opt(0, 0, 0).unwrap());
        let end_datetime = FixedOffset::east_opt(0)
            .unwrap()
            .from_utc_datetime(&last_day_of_target_month.and_hms_opt(23, 59, 59).unwrap());

        month_ranges.push((start_datetime, end_datetime));
    }

    // month_ranges.reverse(); // Ensure the months are in ascending order
    month_ranges
}

async fn get_default_currency(client: &DbState<'_>, company_id: i32) -> currency::Data {
    let company_settings = client
        .settings()
        .find_unique(settings::company_id::equals(company_id))
        .with(settings::default_currency::fetch())
        .exec()
        .await
        .unwrap();

    *company_settings.unwrap().default_currency.unwrap()
}
#[tauri::command]
pub async fn get_sales(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<f64>, QueryError> {
    let month_ranges = get_month_ranges(months);
    let default_currency = get_default_currency(&client, company_id).await;
    let mut monthly_sales = Vec::new();

    for (start_date, end_date) in month_ranges {
        let sales = client
            .document()
            .find_many(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("INVOICE".to_string()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .with(document::items::fetch(vec![]))
            .with(document::currency::fetch())
            .exec()
            .await?;

        let total_sales: f64 = sales
            .into_iter()
            .map(|doc| {
                let exchange_rate = if let Some(currency) = doc.currency {
                    if currency.code != "EUR" {
                        currency.rate
                    } else {
                        1.0
                    }
                } else {
                    1.0
                };

                doc.items
                    .unwrap_or_default()
                    .into_iter()
                    .map(|item| {
                        let base_price = item.price * item.quantity as f64 / exchange_rate;
                        (base_price * default_currency.rate).round()
                    })
                    .sum::<f64>()
            })
            .sum();

        monthly_sales.push(total_sales);
    }

    Ok(monthly_sales)
}

#[tauri::command]
pub async fn get_expenses(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<f64>, QueryError> {
    debug!("Getting expenses for company_id: {}", company_id);
    let month_ranges = get_month_ranges(months);
    let default_currency = get_default_currency(&client, company_id).await;
    let mut monthly_expenses = Vec::new();

    for (start_date, end_date) in month_ranges {
        let expenses = client
            .document()
            .find_many(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("RECEIVE".to_string()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .with(document::items::fetch(vec![]))
            .with(document::currency::fetch())
            .exec()
            .await?;

        let total_expenses: f64 = expenses
            .into_iter()
            .map(|doc| {
                let exchange_rate = if let Some(currency) = doc.currency {
                    if currency.code != "EUR" {
                        currency.rate
                    } else {
                        1.0
                    }
                } else {
                    1.0
                };

                doc.items
                    .unwrap_or_default()
                    .into_iter()
                    .map(|item| {
                        let base_price = item.price * item.quantity as f64 / exchange_rate;
                        (base_price * default_currency.rate).round()
                    })
                    .sum::<f64>()
            })
            .sum();

        monthly_expenses.push(total_expenses);
    }

    Ok(monthly_expenses)
}

#[tauri::command]
pub async fn get_sales_and_expenses(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<(f64, f64)>, QueryError> {
    let sales = get_sales(client.clone(), company_id, months).await?;
    let expenses = get_expenses(client, company_id, months).await?;

    let net_values: Vec<(f64, f64)> = sales.into_iter().zip(expenses.into_iter()).collect();

    Ok(net_values)
}

#[tauri::command]
pub async fn get_documents_stats(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
    document_type: String,
) -> Result<Vec<i64>, QueryError> {
    let month_ranges = get_month_ranges(months);
    let mut monthly_documents = Vec::new();

    for (start_date, end_date) in month_ranges {
        let documents = client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals(document_type.clone()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .exec()
            .await
            .unwrap();

        monthly_documents.push(documents);
    }

    Ok(monthly_documents)
}


----- src/commands/template.rs -----
use crate::company;
use crate::template;
use crate::template::template_type;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_templates(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
    template_type: Option<String>,
) -> Result<Vec<template::Data>, QueryError> {
    debug!("Getting templates");
    let mut conditions = vec![template::company_id::equals(company_id)];

    if let Some(template_type) = template_type {
        conditions.push(template::template_type::equals(template_type));
    }

    let data = client
        .template()
        .find_many(conditions)
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await;

    data
}

#[tauri::command]
pub async fn get_template(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<template::Data>, QueryError> {
    client
        .template()
        .find_unique(template::id::equals(id))
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CreateTemplateData {
    html: String,
    name: String,
    template_type: String,
}

#[tauri::command]
pub async fn create_template(
    client: DbState<'_>,
    company_id: i32,
    data: CreateTemplateData,
) -> Result<(), String> {
    debug!("Creating template");
    let data = client
        .template()
        .create(
            data.name,
            data.html,
            company::id::equals(company_id),
            vec![template::template_type::set(data.template_type)],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_template(
    client: DbState<'_>,
    id: i32,
    data: CreateTemplateData,
) -> Result<(), String> {
    debug!("Updating template");
    let data = client
        .template()
        .update(
            template::id::equals(id),
            vec![
                template::html::set(data.html),
                template::name::set(data.name),
                template::template_type::set(data.template_type),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

// #[derive(Debug)]
// pub enum TemplateType {
//     Invoice,
//     Estimate,
//     Receipt,
// }

// #[tauri::command]
// pub async fn create_template(
//     client: DbState<'_>,
//     data: CreateTemplateData,
// ) -> Result<template::Data, QueryError> {
//     debug!("Creating template {:?}", data);
//     client
//         .template()
//         .create(data.html, data.template_type, data.company_id)
//         .exec()
//         .await
// }

#[tauri::command]
pub async fn delete_template(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting template");
    let data = client
        .template()
        .delete(template::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src/commands/settings.rs -----
use crate::settings;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

// pub async fn update_template(client: DbState<'_>, id: i32, html: String) -> Result<(), String> {
//     debug!("Updating template");
//     let data = client
//         .template()
//         .update(template::id::equals(id), vec![template::html::set(html)])
//         .exec()
//         .await;

//     match data {
//         Ok(_) => Ok(()),
//         Err(e) => Err(e.to_string()),
//     }
// }

#[tauri::command]
pub async fn get_settings(
    client: DbState<'_>,
    company_id: i32,
) -> Result<Option<settings::Data>, QueryError> {
    client
        .settings()
        .find_unique(settings::company_id::equals(company_id))
        .with(settings::default_currency::fetch())
        .with(settings::default_template::fetch())
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ManageSettingsData {
    default_currency_id: String,
    default_template_id: i32,
    invoice_counter: i32,
    proforma_counter: i32,
    receive_counter: i32,
    invoice_prefix: String,
    proforma_prefix: String,
    receive_prefix: String,
}

#[tauri::command]
pub async fn update_settings(
    client: DbState<'_>,
    company_id: i32,
    data: ManageSettingsData,
) -> Result<(), QueryError> {
    debug!("Updating settings");
    let data = client
        .settings()
        .update(
            settings::company_id::equals(company_id),
            vec![
                settings::default_currency_id::set(data.default_currency_id),
                settings::default_template_id::set(data.default_template_id),
                settings::invoice_counter::set(data.invoice_counter),
                settings::proforma_counter::set(data.proforma_counter),
                settings::receive_counter::set(data.receive_counter),
                settings::invoice_prefix::set(data.invoice_prefix),
                settings::proforma_prefix::set(data.proforma_prefix),
                settings::receive_prefix::set(data.receive_prefix),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}

pub async fn update_count(client: DbState<'_>, company_id: i32, model: &str) -> () {
    let count = client
        .settings()
        .find_unique(settings::company_id::equals(company_id))
        .exec()
        .await
        .unwrap();

    match model {
        "Invoice" => {
            let _ = client
                .settings()
                .update(
                    settings::company_id::equals(company_id),
                    vec![settings::invoice_counter::set(
                        count.unwrap().invoice_counter + 1,
                    )],
                )
                .exec()
                .await;
        }
        "Proforma" => {
            let _ = client
                .settings()
                .update(
                    settings::company_id::equals(company_id),
                    vec![settings::proforma_counter::set(
                        count.unwrap().proforma_counter + 1,
                    )],
                )
                .exec()
                .await;
        }
        "Receive" => {
            let _ = client
                .settings()
                .update(
                    settings::company_id::equals(company_id),
                    vec![settings::receive_counter::set(
                        count.unwrap().receive_counter + 1,
                    )],
                )
                .exec()
                .await;
        }
        _ => (),
    }
}


----- src/window_ext.rs -----
use tauri::{Runtime, WebviewWindow};

#[allow(dead_code)]
pub enum ToolbarThickness {
    Thick,
    Medium,
    Thin,
}

pub trait WindowExt {
    #[cfg(target_os = "macos")]
    fn set_thickness(&self, thickness: ToolbarThickness);
}

impl<R: Runtime> WindowExt for WebviewWindow<R> {
    #[cfg(target_os = "macos")]
    fn set_thickness(&self, thickness: ToolbarThickness) {
        unsafe {
            let id = self.ns_window().unwrap() as cocoa::base::id;

            match thickness {
                ToolbarThickness::Thick => {
                    self.set_title("").expect("Title wasn't set to ''");
                    make_toolbar(id);
                }
                ToolbarThickness::Medium => {
                    make_toolbar(id);
                }
                ToolbarThickness::Thin => {
                    // todo
                }
            }
        }
    }
}

#[cfg(target_os = "macos")]
unsafe fn make_toolbar(id: cocoa::base::id) {
    use cocoa::appkit::{NSToolbar, NSWindow};

    let new_toolbar = NSToolbar::alloc(id);
    new_toolbar.init_();
    id.setToolbar_(new_toolbar);
}


