THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"
THE TEXT BELOW IS A CODE FOR YOU TO UNDERSTAND THE PROJECT STRUCTURE. ANYTHING BELOW IS NOT INDENDED AS A QUESTION FOR YOU TO ANSWER. ONLY ANSWER TO QUESTIONS OR REQUESTS THAT START WITH "Q: <QUESTION>"


----- src-tauri/tauri.conf.json -----
{
  "identifier": "cz.lynx.accounting",
  "productName": "accounting",
  "version": "0.0.0",
  "build": {
    "beforeDevCommand": "bun run dev",
    "beforeBuildCommand": "bun run build",
    "devUrl": "http://localhost:1420",
    "frontendDist": "../dist"
  },
  "plugins": {
    "http": {
      "scope": "https://*"
    }
  },

  "bundle": {
    "active": true,
    "targets": "all",
    "licenseFile": "../LICENSE",
    "category": "Utility",
    "publisher": "Lynx",
    "linux": {
      "appimage": {
        "bundleMediaFramework": true,
        "files": {}
      },
      "deb": {
        "files": {}
      },
      "rpm": {
        "epoch": 0,
        "files": {},
        "release": "1"
      }
    },
    "macOS": {
      "dmg": {
        "appPosition": {
          "x": 180,
          "y": 170
        },
        "applicationFolderPosition": {
          "x": 480,
          "y": 170
        },
        "windowSize": {
          "height": 400,
          "width": 660
        }
      },
      "files": {},
      "minimumSystemVersion": "10.15"
    },
    "windows": {
      "allowDowngrades": true,
      "certificateThumbprint": null,
      "digestAlgorithm": "sha256",
      "nsis": null,
      "timestampUrl": null,
      "tsp": false,
      "webviewFixedRuntimePath": null,
      "webviewInstallMode": {
        "silent": true,
        "type": "downloadBootstrapper"
      },
      "wix": null
    },
    "icon": ["icons/32x32.png", "icons/128x128.png", "icons/128x128@2x.png", "icons/icon.icns", "icons/icon.ico"]
  },
  "app": {
    "macOSPrivateApi": true,
    "withGlobalTauri": true,
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "Accounting",
        "width": 900,
        "height": 600,
        "minWidth": 800,
        "minHeight": 550,
        "transparent": true,
        "titleBarStyle": "Overlay",
        "hiddenTitle": true
      }
    ]
  }
}


----- src-tauri/prisma/schema.prisma -----
datasource db {
    provider = "sqlite"
    url      = "file:../app.db"
}

generator client {
    provider    = "cargo prisma"
    output      = "../src/prisma.rs"
    module_path = "crate::db"
}

model Company {
    id         Int        @id @default(autoincrement())
    name       String
    documents  Document[]
    templates  Template[]
    currencies Currency[]
    clients    Client[]
    settings   Settings?

    cin   String  @unique // IČO
    vatId String? @unique // DIČ

    // Adress
    address String
    city    String
    zip     String

    // Additional fields
    phone String?
    email String?
    web   String?

    // Bank account
    bankAccount String?
    bankIban    String?
}

model Client {
    id         Int    @id @default(autoincrement())
    clientType String @default("BOTH") // ENUM = SUPPLIER, CUSTOMER, BOTH

    name  String
    cin   String  @unique // IČO
    vatId String?

    address String
    city    String
    zip     String

    //Contact info
    email String?
    phone String?

    bankAccount String?
    bankCode    String?
    bankName    String?
    bankIban    String?

    documents Document[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Document {
    id           Int    @id @default(autoincrement())
    number       String @unique
    documentType String // ENUM = INVOICE, PROFORMA, RECEIVE

    client   Client @relation(fields: [clientId], references: [id])
    clientId Int

    template   Template @relation(fields: [templateId], references: [id])
    templateId Int

    currency   Currency @relation(fields: [currencyId], references: [id])
    currencyId String

    issueDate DateTime
    // taxDate   DateTime // Datum zdanitelného plnění
    dueDate   DateTime

    status String         @default("DRAFT") // ENUM = DRAFT, PENDING, PAID, CANCELLED, OVERDUE
    items  DocumentItem[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Template {
    id Int @id @default(autoincrement())

    name         String
    html         String
    templateType String     @default("INVOICE") // ENUM = INVOICE, CREDIT_NOTE todo!
    documents    Document[]

    company   Company    @relation(fields: [companyId], references: [id])
    companyId Int
    Settings  Settings[]
}

model DocumentItem {
    id Int @id @default(autoincrement())

    document   Document @relation(fields: [documentId], references: [id])
    documentId Int

    description String
    quantity    Int
    price       Float
    // tax         Float
}

model Settings {
    id Int @id @default(autoincrement())

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int     @unique

    defaultCurrency   Currency @relation(fields: [defaultCurrencyId], references: [id])
    defaultCurrencyId String

    defaultTemplate   Template @relation(fields: [defaultTemplateId], references: [id])
    defaultTemplateId Int
    // tax               Float

    invoicePrefix  String @default("I202400000")
    invoiceCounter Int    @default(1)

    proformaPrefix  String @default("P")
    proformaCounter Int    @default(1)

    receivePrefix  String @default("R")
    receiveCounter Int    @default(1)
}

model Currency {
    id String @id @default(cuid())

    name String
    code String
    rate Float //Rate To EURO

    company   Company    @relation(fields: [companyId], references: [id])
    companyId Int
    documents Document[]

    settings Settings[]
}


----- src-tauri/prisma-cli/src/main.rs -----
fn main() {
    prisma_client_rust_cli::run();
}


----- src-tauri/build.rs -----
fn main() {
  tauri_build::build()
}


----- src-tauri/src/types.rs -----
use serde::Deserialize;

#[derive(Deserialize, Debug)]
pub struct Indicies {
    pub skip: i64,
    pub take: i64,
}


----- src-tauri/src/util.rs -----
use std::path::PathBuf;

/// Get the accoubting config directory.
/// This config directory has the following structure:
/// - data.db
/// - assets/ # All the images/videos/audios are stored here
/// - config.toml
pub fn get_app_dir() -> PathBuf {
    // get app dir with /accounting. use std libary
    let path = platform_dirs::AppDirs::new(Some("accounting"), true).unwrap();
    let mut data_dir = path.data_dir;

    // check if in dev mode
    if cfg!(debug_assertions) {
        // set the dir to ./
        data_dir = PathBuf::from("./");
    }

    data_dir
}


----- src-tauri/src/error.rs -----
use prisma_client_rust::migrations::DbPushError;
use serde::{Serialize, Serializer};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum CoreError {
    #[error("Prisma New Client Error")]
    PrismaNewClientError(#[from] prisma_client_rust::NewClientError),

    #[error("Prisma Query Error")]
    PrismaQueryError(#[from] prisma_client_rust::QueryError),

    #[error("Tokio IO Error")]
    TokioError(#[from] tokio::io::Error),

    #[error("Tokio Join Error")]
    TokioJoinError(#[from] tokio::task::JoinError),

    #[error("Db Push Error")]
    DbPushError(#[from] DbPushError),
}

impl Serialize for CoreError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.to_string().as_ref())
    }
}

pub type CommandResult<T, E = CoreError> = anyhow::Result<T, E>;


----- src-tauri/src/main.rs -----
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

extern crate pretty_env_logger;
#[macro_use]
extern crate log;

#[cfg(target_os = "macos")]
extern crate objc;

#[cfg(target_os = "macos")]
mod window_ext;

#[allow(warnings, unused)]
mod prisma;

mod commands;
mod error;
mod migrator;
mod types;
mod util;

use migrator::new_client;
use prisma::*;
use std::sync::Arc;
use tauri::{Manager, State};

#[cfg(target_os = "macos")]
use window_ext::{ToolbarThickness, WindowExt};
#[cfg(target_os = "macos")]
use window_vibrancy::NSVisualEffectMaterial;

#[cfg(target_os = "windows")]
use window_vibrancy::apply_mica;
#[cfg(target_os = "macos")]
use window_vibrancy::apply_vibrancy;

#[derive(Clone, serde::Serialize)]
struct Payload {
    args: Vec<String>,
    cwd: String,
}

type DbState<'a> = State<'a, Arc<PrismaClient>>;

#[tokio::main]
async fn main() {
    std::env::set_var("RUST_LOG", "trace");
    pretty_env_logger::init();

    let client = new_client().await.unwrap();

    tauri::Builder::default()
        .plugin(tauri_plugin_single_instance::init(|app, argv, cwd| {
            println!("{}, {argv:?}, {cwd}", app.package_info().name);
            app.emit("single-instance", Payload { args: argv, cwd })
                .unwrap();
        }))
        // .plugin(tauri_plugin_updater::Builder::new().build())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_os::init())
        .setup(|app| {
            let window = app.get_webview_window("main").unwrap();

            #[cfg(target_os = "macos")]
            window.set_thickness(ToolbarThickness::Thick);

            #[cfg(target_os = "macos")]
            apply_vibrancy(&window, NSVisualEffectMaterial::HudWindow, None, None)
                .expect("Unsupported platform! 'apply_vibrancy' is only supported on macOS");

            #[cfg(target_os = "windows")]
            apply_mica(&window, Some(true))
                .expect("Unsupported platform! 'apply_mica' is only supported on Windows");

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::db::check_db,
            commands::db::migrate_and_populate,
            commands::company::get_company,
            commands::company::create_company,
            commands::company::get_companies,
            commands::company::update_company,
            commands::document::get_documents,
            commands::document::get_document,
            commands::document::create_document,
            commands::document::get_document_count,
            commands::document::update_document,
            commands::document::delete_document,
            commands::template::get_templates,
            commands::template::get_template,
            commands::template::create_template,
            commands::template::update_template,
            commands::template::delete_template,
            commands::client::get_clients,
            commands::client::get_client,
            commands::client::update_client,
            commands::client::create_client,
            commands::client::delete_client,
            commands::stats::get_sales,
            commands::stats::get_expenses,
            commands::stats::get_documents_stats,
            commands::stats::get_sales_and_expenses,
            commands::other::get_model_count,
            commands::other::get_print_document,
            commands::currency::get_currencies,
            commands::currency::get_currency,
            commands::currency::create_currency,
            commands::currency::update_currency,
            commands::currency::delete_currency,
            commands::settings::get_settings,
            commands::settings::update_settings
        ])
        .manage(Arc::new(client))
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}


----- src-tauri/src/migrator.rs -----
use log::info;

use crate::{
    error::CoreError,
    prisma::{_prisma::PrismaClient, new_client_with_url},
    util::get_app_dir,
};

pub async fn new_client() -> Result<PrismaClient, CoreError> {
    let appdata_url = get_app_dir().join("app.db");

    log::info!("Connecting to database at {}", appdata_url.display());

    tokio::fs::create_dir_all(appdata_url.parent().unwrap()).await?;

    if !appdata_url.exists() {
        tokio::fs::File::create(appdata_url.clone()).await?;
        info!("Created database at {}", appdata_url.display());
    }

    let client =
        new_client_with_url(&("file:".to_string() + appdata_url.to_str().unwrap())).await?;

    Ok(client)
}


----- src-tauri/src/commands/other.rs -----
use crate::client;
use crate::company;
use crate::currency;
use crate::document;
use crate::template;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_model_count(
    client: DbState<'_>,
    company_id: i32,
    model: String,
) -> Result<i64, String> {
    match model.as_str() {
        "Invoice" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("INVOICE".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting invoices: {}", e)),
        "Proforma" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("PROFORMA".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting proformas: {}", e)),
        "Receive" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("RECEIVE".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting received invoices: {}", e)),
        "Company" => client
            .company()
            .count(vec![company::id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting companies: {}", e)),
        "Client" => client
            .client()
            .count(vec![client::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting clients: {}", e)),
        "Template" => client
            .template()
            .count(vec![template::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting templates: {}", e)),
        "Currency" => client
            .currency()
            .count(vec![currency::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting currencies: {}", e)),
        _ => Err("Model not found".to_string()),
    }
}

#[tauri::command]
pub async fn get_print_document(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<document::Data>, QueryError> {
    client
        .document()
        .find_unique(document::id::equals(id))
        .with(document::items::fetch(vec![]))
        .with(document::currency::fetch())
        .with(document::client::fetch())
        .with(document::template::fetch())
        .with(document::company::fetch())
        .exec()
        .await
}


----- src-tauri/src/commands/client.rs -----
use crate::client;
use crate::company;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_clients(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<client::Data>, QueryError> {
    debug!(
        "Getting clients from {} with indicies {:?}",
        company_id, indicies
    );
    client
        .client()
        .find_many(vec![client::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await
}

#[tauri::command]
pub async fn get_client(client: DbState<'_>, id: i32) -> Result<Option<client::Data>, QueryError> {
    client
        .client()
        .find_unique(client::id::equals(id))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Creating client");
    let data = client
        .client()
        .create(
            data.name,
            data.cin,
            data.address,
            data.city,
            data.zip,
            company::id::equals(data.company_id),
            vec![
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Updating client");
    let data = client
        .client()
        .update(
            client::id::equals(data.id),
            vec![
                client::name::set(data.name),
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::cin::set(data.cin),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
                client::address::set(data.address),
                client::city::set(data.city),
                client::zip::set(data.zip),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_client(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting client");
    let data = client.client().delete(client::id::equals(id)).exec().await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src-tauri/src/commands/company.rs -----
use crate::company;
use crate::currency;
use crate::template;
use crate::DbState;
use prisma_client_rust::not;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_companies(
    client: DbState<'_>,
    exclude: Option<i32>,
) -> Result<Vec<company::Data>, QueryError> {
    println!("Getting companies, exluding {:?}", exclude);
    let data = client
        .company()
        .find_many(vec![not![company::id::equals(exclude.unwrap_or(999))]])
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_company(
    client: DbState<'_>,
    id: Option<i32>,
) -> Result<Option<company::Data>, QueryError> {
    client
        .company()
        .find_first(vec![company::id::equals(id.unwrap_or(1))])
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ManageCompanyData {
    name: String,
    cin: String,
    vat_id: Option<String>,
    address: String,
    city: String,
    zip: String,
    phone: Option<String>,
    email: Option<String>,

    bank_account: Option<String>,
    bank_iban: Option<String>,
}

#[tauri::command]
pub async fn create_company(
    client: DbState<'_>,
    data: ManageCompanyData,
) -> Result<i32, QueryError> {
    debug!("Creating company {:?}", data);
    let company = client
        .company()
        .create(
            data.name,
            data.cin,
            data.address,
            data.city,
            data.zip,
            vec![
                company::vat_id::set(data.vat_id),
                company::email::set(data.email),
                company::phone::set(data.phone),
                company::bank_account::set(data.bank_account),
                company::bank_iban::set(data.bank_iban),
            ],
        )
        .exec()
        .await
        .unwrap();

    let currency = client
        .currency()
        .create(
            "Euro".to_string(),
            "EUR".to_string(),
            1.0,
            company::id::equals(company.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    let template = client
        .template()
        .create(
            "Default Invoice".to_string(),
            "<html><body><h1>Invoice</h1></body></html>".to_string(),
            company::id::equals(company.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    let _settings = client
        .settings()
        .create(
            company::id::equals(company.id),
            currency::id::equals(currency.id),
            template::id::equals(template.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    Ok(company.id)
}

#[tauri::command]
pub async fn update_company(
    client: DbState<'_>,
    id: i32,
    data: ManageCompanyData,
) -> Result<(), QueryError> {
    debug!("Updating company");
    println!("{:?}", data);
    let data = client
        .company()
        .update(
            company::id::equals(id),
            vec![
                company::name::set(data.name),
                company::cin::set(data.cin),
                company::vat_id::set(data.vat_id),
                company::address::set(data.address),
                company::city::set(data.city),
                company::zip::set(data.zip),
                company::phone::set(data.phone),
                company::email::set(data.email),
                company::bank_account::set(data.bank_account),
                company::bank_iban::set(data.bank_iban),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}


----- src-tauri/src/commands/db.rs -----
use crate::error::CommandResult;
// use crate::migrator::new_client;
use crate::DbState;

// #[specta::specta]
#[tauri::command]
pub async fn check_db(client: DbState<'_>) -> CommandResult<i16> {
    let company_count = client.company().count(vec![]).exec().await;

    info!("Checking DB");
    match company_count {
        Ok(_) => {
            if company_count.unwrap() == 0 {
                return Ok(400);
            }
            return Ok(200);
        }
        Err(_) => Ok(400),
    }
}

// #[specta::specta]
#[tauri::command]
pub async fn migrate_and_populate(client: DbState<'_>) -> CommandResult<()> {
    #[cfg(not(debug_assertions))]
    client._db_push().await?;

    #[cfg(not(debug_assertions))]
    client._migrate_deploy().await.unwrap();

    Ok(())
}


----- src-tauri/src/commands/mod.rs -----
pub mod client;
pub mod company;
pub mod currency;
pub mod db;
pub mod document;
pub mod other;
pub mod settings;
pub mod stats;
pub mod template;


----- src-tauri/src/commands/currency.rs -----
use crate::company;
use crate::currency;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_currencies(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<currency::Data>, QueryError> {
    debug!("Getting currencies");
    let data = client
        .currency()
        .find_many(vec![currency::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_currency(
    client: DbState<'_>,
    id: String,
) -> Result<Option<currency::Data>, QueryError> {
    client
        .currency()
        .find_first(vec![currency::id::equals(id)])
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CurrencyData {
    name: String,
    code: String,
    rate: f64,
}
#[tauri::command]
pub async fn create_currency(
    client: DbState<'_>,
    company_id: i32,
    data: CurrencyData,
) -> Result<(), String> {
    debug!("Creating currency");
    let data = client
        .currency()
        .create(
            data.name,
            data.code,
            data.rate,
            company::id::equals(company_id),
            vec![],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_currency(
    client: DbState<'_>,
    id: String,
    data: CurrencyData,
) -> Result<(), String> {
    debug!("Updating currency");
    let data = client
        .currency()
        .update(
            currency::id::equals(id),
            vec![
                currency::name::set(data.name),
                currency::code::set(data.code),
                currency::rate::set(data.rate),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_currency(client: DbState<'_>, id: String) -> Result<(), String> {
    debug!("Deleting currency");
    let data = client
        .currency()
        .delete(currency::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src-tauri/src/commands/document.rs -----
use crate::client;
use crate::commands::settings::update_count;
use crate::company;
use crate::currency;
use crate::document;
use crate::document_item;
use crate::template;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::chrono::{DateTime, FixedOffset};
use prisma_client_rust::Direction;
use prisma_client_rust::QueryError;

use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct DocumentWithPrice {
    id: i32,
    number: String,
    document_type: String,
    client_id: i32,
    template_id: i32,
    currency: String,
    issue_date: DateTime<FixedOffset>,
    due_date: DateTime<FixedOffset>,
    company_id: i32,
    status: String,
    items: Option<Vec<document_item::Data>>,
    total_price: f64,
}

#[tauri::command]
pub async fn get_documents(
    client: DbState<'_>,
    company_id: i32,
    document_type: Option<String>,
    indicies: Indicies,
    client_id: Option<i32>,
) -> Result<Vec<DocumentWithPrice>, QueryError> {
    debug!(
        "Getting documents from {} with type {:?} and indicies {:?}",
        company_id, document_type, indicies
    );

    let mut conditions = vec![document::company_id::equals(company_id)];

    if let Some(client_id) = client_id {
        conditions.push(document::client_id::equals(client_id));
    }
    if let Some(document_type) = document_type {
        conditions.push(document::document_type::equals(document_type));
    }

    let documents = client
        .document()
        .find_many(conditions)
        .order_by(document::id::order(Direction::Desc))
        .with(document::items::fetch(vec![]))
        .with(document::currency::fetch())
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await?;

    let documents_with_price = documents
        .into_iter()
        .map(|doc| {
            let total_price: f64 = doc
                .items
                .as_ref()
                .unwrap_or(&vec![])
                .iter()
                .map(|item| item.price * item.quantity as f64)
                .sum();
            DocumentWithPrice {
                id: doc.id,
                number: doc.number,
                document_type: doc.document_type,
                client_id: doc.client_id,
                template_id: doc.template_id,
                currency: doc.currency.unwrap().code,
                issue_date: doc.issue_date,
                due_date: doc.due_date,
                company_id: doc.company_id,
                status: doc.status,
                items: doc.items,
                total_price,
            }
        })
        .collect::<Vec<DocumentWithPrice>>();

    Ok(documents_with_price)
}

#[tauri::command]
pub async fn get_document_count(
    client: DbState<'_>,
    document_type: Option<String>,
    client_id: Option<i32>,
) -> Result<i64, QueryError> {
    let mut conditions = vec![];

    if let Some(client_id) = client_id {
        conditions.push(document::client_id::equals(client_id));
    }
    if let Some(document_type) = document_type {
        conditions.push(document::document_type::equals(document_type));
    }

    client.document().count(conditions).exec().await
}

#[tauri::command]
pub async fn get_document(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<document::Data>, QueryError> {
    client
        .document()
        .find_unique(document::id::equals(id))
        .with(document::items::fetch(vec![]))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Creating document");
    let res = client
        .document()
        .create(
            data.number,
            data.document_type,
            client::id::equals(data.client_id),
            template::id::equals(data.template_id),
            currency::id::equals(data.currency_id),
            data.issue_date,
            data.due_date,
            company::id::equals(data.company_id),
            vec![document::status::set(data.status)],
        )
        .exec()
        .await;

    if let Some(items) = data.items {
        for item in items.iter() {
            let _ = client
                .document_item()
                .create(
                    document::id::equals(res.as_ref().unwrap().company_id),
                    item.description.clone(),
                    item.quantity,
                    item.price,
                    vec![],
                )
                .exec()
                .await
                .unwrap();
        }
    }

    match res {
        Ok(_) => {
            update_count(client, data.company_id, "Invoice").await;
            Ok(())
        }
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Updating document");

    // Update the document fields
    let updated_document = client
        .document()
        .update(
            document::id::equals(data.id),
            vec![
                document::number::set(data.number),
                document::document_type::set(data.document_type),
                document::client_id::set(data.client_id),
                document::template_id::set(data.template_id),
                document::currency_id::set(data.currency_id),
                document::issue_date::set(data.issue_date),
                document::due_date::set(data.due_date),
                document::status::set(data.status),
            ],
        )
        .exec()
        .await;

    match updated_document {
        Ok(_) => {
            let _ = client
                .document_item()
                .delete_many(vec![document_item::document_id::equals(data.id)])
                .exec()
                .await;

            if let Some(items) = data.items {
                for item in items.iter() {
                    println!("ITEMS: {:?}", item);
                    let _ = client
                        .document_item()
                        .create(
                            document::id::equals(data.id),
                            item.description.clone(),
                            item.quantity,
                            item.price,
                            vec![],
                        )
                        .exec()
                        .await;
                }
            }

            Ok(())
        }
        Err(e) => {
            error!("Error updating document: {}", e);
            Err(e.to_string())
        }
    }
}

#[tauri::command]
pub async fn delete_document(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting document");
    let data = client
        .document()
        .delete(document::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src-tauri/src/commands/stats.rs -----
use crate::currency;
use crate::document;
use crate::settings;
use crate::DbState;
use prisma_client_rust::chrono::{DateTime, Datelike, Duration, FixedOffset, Local, TimeZone};
use prisma_client_rust::QueryError;

fn get_month_ranges(months: i32) -> Vec<(DateTime<FixedOffset>, DateTime<FixedOffset>)> {
    let today = Local::now();
    let today_naive = today.naive_local().date();
    let mut month_ranges = Vec::new();

    for month_offset in 0..months {
        let target_month = (today_naive.month() as i32 - month_offset - 1).rem_euclid(12) + 1;
        let year_adjustment = (today_naive.month() as i32 - month_offset - 1) / 12;
        let adjusted_year = today_naive.year() + year_adjustment;

        let first_day_of_target_month = today_naive
            .with_year(adjusted_year)
            .unwrap()
            .with_month(target_month as u32)
            .unwrap()
            .with_day(1)
            .unwrap();
        let last_day_of_target_month = first_day_of_target_month
            .with_month((target_month % 12 + 1) as u32)
            .unwrap_or_else(|| {
                first_day_of_target_month
                    .with_year(adjusted_year + 1)
                    .unwrap()
                    .with_month(1)
                    .unwrap()
            })
            - Duration::days(1);

        let start_datetime = FixedOffset::east_opt(0)
            .unwrap()
            .from_utc_datetime(&first_day_of_target_month.and_hms_opt(0, 0, 0).unwrap());
        let end_datetime = FixedOffset::east_opt(0)
            .unwrap()
            .from_utc_datetime(&last_day_of_target_month.and_hms_opt(23, 59, 59).unwrap());

        month_ranges.push((start_datetime, end_datetime));
    }

    // month_ranges.reverse(); // Ensure the months are in ascending order
    month_ranges
}

async fn get_default_currency(client: &DbState<'_>, company_id: i32) -> currency::Data {
    let company_settings = client
        .settings()
        .find_unique(settings::company_id::equals(company_id))
        .with(settings::default_currency::fetch())
        .exec()
        .await
        .unwrap();

    *company_settings.unwrap().default_currency.unwrap()
}
#[tauri::command]
pub async fn get_sales(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<f64>, QueryError> {
    let month_ranges = get_month_ranges(months);
    let default_currency = get_default_currency(&client, company_id).await;
    let mut monthly_sales = Vec::new();

    for (start_date, end_date) in month_ranges {
        let sales = client
            .document()
            .find_many(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("INVOICE".to_string()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .with(document::items::fetch(vec![]))
            .with(document::currency::fetch())
            .exec()
            .await?;

        let total_sales: f64 = sales
            .into_iter()
            .map(|doc| {
                let exchange_rate = if let Some(currency) = doc.currency {
                    if currency.code != "EUR" {
                        currency.rate
                    } else {
                        1.0
                    }
                } else {
                    1.0
                };

                doc.items
                    .unwrap_or_default()
                    .into_iter()
                    .map(|item| {
                        let base_price = item.price * item.quantity as f64 / exchange_rate;
                        (base_price * default_currency.rate).round()
                    })
                    .sum::<f64>()
            })
            .sum();

        monthly_sales.push(total_sales);
    }

    Ok(monthly_sales)
}

#[tauri::command]
pub async fn get_expenses(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<f64>, QueryError> {
    debug!("Getting expenses for company_id: {}", company_id);
    let month_ranges = get_month_ranges(months);
    let default_currency = get_default_currency(&client, company_id).await;
    let mut monthly_expenses = Vec::new();

    for (start_date, end_date) in month_ranges {
        let expenses = client
            .document()
            .find_many(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("RECEIVE".to_string()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .with(document::items::fetch(vec![]))
            .with(document::currency::fetch())
            .exec()
            .await?;

        let total_expenses: f64 = expenses
            .into_iter()
            .map(|doc| {
                let exchange_rate = if let Some(currency) = doc.currency {
                    if currency.code != "EUR" {
                        currency.rate
                    } else {
                        1.0
                    }
                } else {
                    1.0
                };

                doc.items
                    .unwrap_or_default()
                    .into_iter()
                    .map(|item| {
                        let base_price = item.price * item.quantity as f64 / exchange_rate;
                        (base_price * default_currency.rate).round()
                    })
                    .sum::<f64>()
            })
            .sum();

        monthly_expenses.push(total_expenses);
    }

    Ok(monthly_expenses)
}

#[tauri::command]
pub async fn get_sales_and_expenses(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<(f64, f64)>, QueryError> {
    let sales = get_sales(client.clone(), company_id, months).await?;
    let expenses = get_expenses(client, company_id, months).await?;

    let net_values: Vec<(f64, f64)> = sales.into_iter().zip(expenses.into_iter()).collect();

    Ok(net_values)
}

#[tauri::command]
pub async fn get_documents_stats(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
    document_type: String,
) -> Result<Vec<i64>, QueryError> {
    let month_ranges = get_month_ranges(months);
    let mut monthly_documents = Vec::new();

    for (start_date, end_date) in month_ranges {
        let documents = client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals(document_type.clone()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .exec()
            .await
            .unwrap();

        monthly_documents.push(documents);
    }

    Ok(monthly_documents)
}


----- src-tauri/src/commands/template.rs -----
use crate::company;
use crate::template;
use crate::template::template_type;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_templates(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
    template_type: Option<String>,
) -> Result<Vec<template::Data>, QueryError> {
    debug!("Getting templates");
    let mut conditions = vec![template::company_id::equals(company_id)];

    if let Some(template_type) = template_type {
        conditions.push(template::template_type::equals(template_type));
    }

    let data = client
        .template()
        .find_many(conditions)
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await;

    data
}

#[tauri::command]
pub async fn get_template(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<template::Data>, QueryError> {
    client
        .template()
        .find_unique(template::id::equals(id))
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CreateTemplateData {
    html: String,
    name: String,
    template_type: String,
}

#[tauri::command]
pub async fn create_template(
    client: DbState<'_>,
    company_id: i32,
    data: CreateTemplateData,
) -> Result<(), String> {
    debug!("Creating template");
    let data = client
        .template()
        .create(
            data.name,
            data.html,
            company::id::equals(company_id),
            vec![template::template_type::set(data.template_type)],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_template(
    client: DbState<'_>,
    id: i32,
    data: CreateTemplateData,
) -> Result<(), String> {
    debug!("Updating template");
    let data = client
        .template()
        .update(
            template::id::equals(id),
            vec![
                template::html::set(data.html),
                template::name::set(data.name),
                template::template_type::set(data.template_type),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

// #[derive(Debug)]
// pub enum TemplateType {
//     Invoice,
//     Estimate,
//     Receipt,
// }

// #[tauri::command]
// pub async fn create_template(
//     client: DbState<'_>,
//     data: CreateTemplateData,
// ) -> Result<template::Data, QueryError> {
//     debug!("Creating template {:?}", data);
//     client
//         .template()
//         .create(data.html, data.template_type, data.company_id)
//         .exec()
//         .await
// }

#[tauri::command]
pub async fn delete_template(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting template");
    let data = client
        .template()
        .delete(template::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src-tauri/src/commands/settings.rs -----
use crate::settings;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

// pub async fn update_template(client: DbState<'_>, id: i32, html: String) -> Result<(), String> {
//     debug!("Updating template");
//     let data = client
//         .template()
//         .update(template::id::equals(id), vec![template::html::set(html)])
//         .exec()
//         .await;

//     match data {
//         Ok(_) => Ok(()),
//         Err(e) => Err(e.to_string()),
//     }
// }

#[tauri::command]
pub async fn get_settings(
    client: DbState<'_>,
    company_id: i32,
) -> Result<Option<settings::Data>, QueryError> {
    client
        .settings()
        .find_unique(settings::company_id::equals(company_id))
        .with(settings::default_currency::fetch())
        .with(settings::default_template::fetch())
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ManageSettingsData {
    default_currency_id: String,
    default_template_id: i32,
    invoice_counter: i32,
    proforma_counter: i32,
    receive_counter: i32,
    invoice_prefix: String,
    proforma_prefix: String,
    receive_prefix: String,
}

#[tauri::command]
pub async fn update_settings(
    client: DbState<'_>,
    company_id: i32,
    data: ManageSettingsData,
) -> Result<(), QueryError> {
    debug!("Updating settings");
    let data = client
        .settings()
        .update(
            settings::company_id::equals(company_id),
            vec![
                settings::default_currency_id::set(data.default_currency_id),
                settings::default_template_id::set(data.default_template_id),
                settings::invoice_counter::set(data.invoice_counter),
                settings::proforma_counter::set(data.proforma_counter),
                settings::receive_counter::set(data.receive_counter),
                settings::invoice_prefix::set(data.invoice_prefix),
                settings::proforma_prefix::set(data.proforma_prefix),
                settings::receive_prefix::set(data.receive_prefix),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}

pub async fn update_count(client: DbState<'_>, company_id: i32, model: &str) -> () {
    let count = client
        .settings()
        .find_unique(settings::company_id::equals(company_id))
        .exec()
        .await
        .unwrap();

    match model {
        "Invoice" => {
            let _ = client
                .settings()
                .update(
                    settings::company_id::equals(company_id),
                    vec![settings::invoice_counter::set(
                        count.unwrap().invoice_counter + 1,
                    )],
                )
                .exec()
                .await;
        }
        "Proforma" => {
            let _ = client
                .settings()
                .update(
                    settings::company_id::equals(company_id),
                    vec![settings::proforma_counter::set(
                        count.unwrap().proforma_counter + 1,
                    )],
                )
                .exec()
                .await;
        }
        "Receive" => {
            let _ = client
                .settings()
                .update(
                    settings::company_id::equals(company_id),
                    vec![settings::receive_counter::set(
                        count.unwrap().receive_counter + 1,
                    )],
                )
                .exec()
                .await;
        }
        _ => (),
    }
}


----- src-tauri/src/window_ext.rs -----
use tauri::{Runtime, WebviewWindow};

#[allow(dead_code)]
pub enum ToolbarThickness {
    Thick,
    Medium,
    Thin,
}

pub trait WindowExt {
    #[cfg(target_os = "macos")]
    fn set_thickness(&self, thickness: ToolbarThickness);
}

impl<R: Runtime> WindowExt for WebviewWindow<R> {
    #[cfg(target_os = "macos")]
    fn set_thickness(&self, thickness: ToolbarThickness) {
        unsafe {
            let id = self.ns_window().unwrap() as cocoa::base::id;

            match thickness {
                ToolbarThickness::Thick => {
                    self.set_title("").expect("Title wasn't set to ''");
                    make_toolbar(id);
                }
                ToolbarThickness::Medium => {
                    make_toolbar(id);
                }
                ToolbarThickness::Thin => {
                    // todo
                }
            }
        }
    }
}

#[cfg(target_os = "macos")]
unsafe fn make_toolbar(id: cocoa::base::id) {
    use cocoa::appkit::{NSToolbar, NSWindow};

    let new_toolbar = NSToolbar::alloc(id);
    new_toolbar.init_();
    id.setToolbar_(new_toolbar);
}


----- output.txt -----
----- src-tauri/tauri.conf.json -----
{
  "identifier": "cz.lynx.accounting",
  "productName": "accounting",
  "version": "0.0.0",
  "build": {
    "beforeDevCommand": "bun run dev",
    "beforeBuildCommand": "bun run build",
    "devUrl": "http://localhost:1420",
    "frontendDist": "../dist"
  },
  "plugins": {
    "http": {
      "scope": "https://*"
    }
  },

  "bundle": {
    "active": true,
    "targets": "all",
    "licenseFile": "../LICENSE",
    "category": "Utility",
    "publisher": "Lynx",
    "linux": {
      "appimage": {
        "bundleMediaFramework": true,
        "files": {}
      },
      "deb": {
        "files": {}
      },
      "rpm": {
        "epoch": 0,
        "files": {},
        "release": "1"
      }
    },
    "macOS": {
      "dmg": {
        "appPosition": {
          "x": 180,
          "y": 170
        },
        "applicationFolderPosition": {
          "x": 480,
          "y": 170
        },
        "windowSize": {
          "height": 400,
          "width": 660
        }
      },
      "files": {},
      "minimumSystemVersion": "10.15"
    },
    "windows": {
      "allowDowngrades": true,
      "certificateThumbprint": null,
      "digestAlgorithm": "sha256",
      "nsis": null,
      "timestampUrl": null,
      "tsp": false,
      "webviewFixedRuntimePath": null,
      "webviewInstallMode": {
        "silent": true,
        "type": "downloadBootstrapper"
      },
      "wix": null
    },
    "icon": ["icons/32x32.png", "icons/128x128.png", "icons/128x128@2x.png", "icons/icon.icns", "icons/icon.ico"]
  },
  "app": {
    "macOSPrivateApi": true,
    "withGlobalTauri": true,
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "Accounting",
        "width": 900,
        "height": 600,
        "minWidth": 800,
        "minHeight": 550,
        "transparent": true,
        "titleBarStyle": "Overlay",
        "hiddenTitle": true
      }
    ]
  }
}


----- src-tauri/prisma/schema.prisma -----
datasource db {
    provider = "sqlite"
    url      = "file:../app.db"
}

generator client {
    provider    = "cargo prisma"
    output      = "../src/prisma.rs"
    module_path = "crate::db"
}

model Company {
    id         Int        @id @default(autoincrement())
    name       String
    documents  Document[]
    templates  Template[]
    currencies Currency[]
    clients    Client[]
    settings   Settings?

    cin   String  @unique // IČO
    vatId String? @unique // DIČ

    // Adress
    address String
    city    String
    zip     String

    // Additional fields
    phone String?
    email String?
    web   String?

    // Bank account
    bankAccount String?
    bankIban    String?
}

model Client {
    id         Int    @id @default(autoincrement())
    clientType String @default("BOTH") // ENUM = SUPPLIER, CUSTOMER, BOTH

    name  String
    cin   String  @unique // IČO
    vatId String?

    address String
    city    String
    zip     String

    //Contact info
    email String?
    phone String?

    bankAccount String?
    bankCode    String?
    bankName    String?
    bankIban    String?

    documents Document[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Document {
    id           Int    @id @default(autoincrement())
    number       String @unique
    documentType String // ENUM = INVOICE, PROFORMA, RECEIVE

    client   Client @relation(fields: [clientId], references: [id])
    clientId Int

    template   Template @relation(fields: [templateId], references: [id])
    templateId Int

    currency   Currency @relation(fields: [currencyId], references: [id])
    currencyId String

    issueDate DateTime
    // taxDate   DateTime // Datum zdanitelného plnění
    dueDate   DateTime

    status String         @default("DRAFT") // ENUM = DRAFT, PENDING, PAID, CANCELLED, OVERDUE
    items  DocumentItem[]

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int
}

model Template {
    id Int @id @default(autoincrement())

    name         String
    html         String
    templateType String     @default("INVOICE") // ENUM = INVOICE, CREDIT_NOTE todo!
    documents    Document[]

    company   Company    @relation(fields: [companyId], references: [id])
    companyId Int
    Settings  Settings[]
}

model DocumentItem {
    id Int @id @default(autoincrement())

    document   Document @relation(fields: [documentId], references: [id])
    documentId Int

    description String
    quantity    Int
    price       Float
    // tax         Float
}

model Settings {
    id Int @id @default(autoincrement())

    company   Company @relation(fields: [companyId], references: [id])
    companyId Int     @unique

    defaultCurrency   Currency @relation(fields: [defaultCurrencyId], references: [id])
    defaultCurrencyId String

    defaultTemplate   Template @relation(fields: [defaultTemplateId], references: [id])
    defaultTemplateId Int
    // tax               Float

    invoicePrefix  String @default("I202400000")
    invoiceCounter Int    @default(1)

    proformaPrefix  String @default("P")
    proformaCounter Int    @default(1)

    receivePrefix  String @default("R")
    receiveCounter Int    @default(1)
}

model Currency {
    id String @id @default(cuid())

    name String
    code String
    rate Float //Rate To EURO

    company   Company    @relation(fields: [companyId], references: [id])
    companyId Int
    documents Document[]

    settings Settings[]
}


----- src-tauri/prisma-cli/src/main.rs -----
fn main() {
    prisma_client_rust_cli::run();
}


----- src-tauri/build.rs -----
fn main() {
  tauri_build::build()
}


----- src-tauri/src/types.rs -----
use serde::Deserialize;

#[derive(Deserialize, Debug)]
pub struct Indicies {
    pub skip: i64,
    pub take: i64,
}


----- src-tauri/src/util.rs -----
use std::path::PathBuf;

/// Get the accoubting config directory.
/// This config directory has the following structure:
/// - data.db
/// - assets/ # All the images/videos/audios are stored here
/// - config.toml
pub fn get_app_dir() -> PathBuf {
    // get app dir with /accounting. use std libary
    let path = platform_dirs::AppDirs::new(Some("accounting"), true).unwrap();
    let mut data_dir = path.data_dir;

    // check if in dev mode
    if cfg!(debug_assertions) {
        // set the dir to ./
        data_dir = PathBuf::from("./");
    }

    data_dir
}


----- src-tauri/src/error.rs -----
use prisma_client_rust::migrations::DbPushError;
use serde::{Serialize, Serializer};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum CoreError {
    #[error("Prisma New Client Error")]
    PrismaNewClientError(#[from] prisma_client_rust::NewClientError),

    #[error("Prisma Query Error")]
    PrismaQueryError(#[from] prisma_client_rust::QueryError),

    #[error("Tokio IO Error")]
    TokioError(#[from] tokio::io::Error),

    #[error("Tokio Join Error")]
    TokioJoinError(#[from] tokio::task::JoinError),

    #[error("Db Push Error")]
    DbPushError(#[from] DbPushError),
}

impl Serialize for CoreError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.to_string().as_ref())
    }
}

pub type CommandResult<T, E = CoreError> = anyhow::Result<T, E>;


----- src-tauri/src/main.rs -----
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

extern crate pretty_env_logger;
#[macro_use]
extern crate log;

#[cfg(target_os = "macos")]
extern crate objc;

#[cfg(target_os = "macos")]
mod window_ext;

#[allow(warnings, unused)]
mod prisma;

mod commands;
mod error;
mod migrator;
mod types;
mod util;

use migrator::new_client;
use prisma::*;
use std::sync::Arc;
use tauri::{Manager, State};

#[cfg(target_os = "macos")]
use window_ext::{ToolbarThickness, WindowExt};
#[cfg(target_os = "macos")]
use window_vibrancy::NSVisualEffectMaterial;

#[cfg(target_os = "windows")]
use window_vibrancy::apply_mica;
#[cfg(target_os = "macos")]
use window_vibrancy::apply_vibrancy;

#[derive(Clone, serde::Serialize)]
struct Payload {
    args: Vec<String>,
    cwd: String,
}

type DbState<'a> = State<'a, Arc<PrismaClient>>;

#[tokio::main]
async fn main() {
    std::env::set_var("RUST_LOG", "trace");
    pretty_env_logger::init();

    let client = new_client().await.unwrap();

    tauri::Builder::default()
        .plugin(tauri_plugin_single_instance::init(|app, argv, cwd| {
            println!("{}, {argv:?}, {cwd}", app.package_info().name);
            app.emit("single-instance", Payload { args: argv, cwd })
                .unwrap();
        }))
        // .plugin(tauri_plugin_updater::Builder::new().build())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_os::init())
        .setup(|app| {
            let window = app.get_webview_window("main").unwrap();

            #[cfg(target_os = "macos")]
            window.set_thickness(ToolbarThickness::Thick);

            #[cfg(target_os = "macos")]
            apply_vibrancy(&window, NSVisualEffectMaterial::HudWindow, None, None)
                .expect("Unsupported platform! 'apply_vibrancy' is only supported on macOS");

            #[cfg(target_os = "windows")]
            apply_mica(&window, Some(true))
                .expect("Unsupported platform! 'apply_mica' is only supported on Windows");

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::db::check_db,
            commands::db::migrate_and_populate,
            commands::company::get_company,
            commands::company::create_company,
            commands::company::get_companies,
            commands::company::update_company,
            commands::document::get_documents,
            commands::document::get_document,
            commands::document::create_document,
            commands::document::get_document_count,
            commands::document::update_document,
            commands::document::delete_document,
            commands::template::get_templates,
            commands::template::get_template,
            commands::template::create_template,
            commands::template::update_template,
            commands::template::delete_template,
            commands::client::get_clients,
            commands::client::get_client,
            commands::client::update_client,
            commands::client::create_client,
            commands::client::delete_client,
            commands::stats::get_sales,
            commands::stats::get_expenses,
            commands::stats::get_documents_stats,
            commands::stats::get_sales_and_expenses,
            commands::other::get_model_count,
            commands::other::get_print_document,
            commands::currency::get_currencies,
            commands::currency::get_currency,
            commands::currency::create_currency,
            commands::currency::update_currency,
            commands::currency::delete_currency,
            commands::settings::get_settings,
            commands::settings::update_settings
        ])
        .manage(Arc::new(client))
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}


----- src-tauri/src/migrator.rs -----
use log::info;

use crate::{
    error::CoreError,
    prisma::{_prisma::PrismaClient, new_client_with_url},
    util::get_app_dir,
};

pub async fn new_client() -> Result<PrismaClient, CoreError> {
    let appdata_url = get_app_dir().join("app.db");

    log::info!("Connecting to database at {}", appdata_url.display());

    tokio::fs::create_dir_all(appdata_url.parent().unwrap()).await?;

    if !appdata_url.exists() {
        tokio::fs::File::create(appdata_url.clone()).await?;
        info!("Created database at {}", appdata_url.display());
    }

    let client =
        new_client_with_url(&("file:".to_string() + appdata_url.to_str().unwrap())).await?;

    Ok(client)
}


----- src-tauri/src/commands/other.rs -----
use crate::client;
use crate::company;
use crate::currency;
use crate::document;
use crate::template;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_model_count(
    client: DbState<'_>,
    company_id: i32,
    model: String,
) -> Result<i64, String> {
    match model.as_str() {
        "Invoice" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("INVOICE".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting invoices: {}", e)),
        "Proforma" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("PROFORMA".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting proformas: {}", e)),
        "Receive" => client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("RECEIVE".to_string()),
            ])
            .exec()
            .await
            .map_err(|e| format!("Error counting received invoices: {}", e)),
        "Company" => client
            .company()
            .count(vec![company::id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting companies: {}", e)),
        "Client" => client
            .client()
            .count(vec![client::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting clients: {}", e)),
        "Template" => client
            .template()
            .count(vec![template::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting templates: {}", e)),
        "Currency" => client
            .currency()
            .count(vec![currency::company_id::equals(company_id)])
            .exec()
            .await
            .map_err(|e| format!("Error counting currencies: {}", e)),
        _ => Err("Model not found".to_string()),
    }
}

#[tauri::command]
pub async fn get_print_document(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<document::Data>, QueryError> {
    client
        .document()
        .find_unique(document::id::equals(id))
        .with(document::items::fetch(vec![]))
        .with(document::currency::fetch())
        .with(document::client::fetch())
        .with(document::template::fetch())
        .with(document::company::fetch())
        .exec()
        .await
}


----- src-tauri/src/commands/client.rs -----
use crate::client;
use crate::company;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;

#[tauri::command]
pub async fn get_clients(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<client::Data>, QueryError> {
    debug!(
        "Getting clients from {} with indicies {:?}",
        company_id, indicies
    );
    client
        .client()
        .find_many(vec![client::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await
}

#[tauri::command]
pub async fn get_client(client: DbState<'_>, id: i32) -> Result<Option<client::Data>, QueryError> {
    client
        .client()
        .find_unique(client::id::equals(id))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Creating client");
    let data = client
        .client()
        .create(
            data.name,
            data.cin,
            data.address,
            data.city,
            data.zip,
            company::id::equals(data.company_id),
            vec![
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_client(client: DbState<'_>, data: client::Data) -> Result<(), String> {
    debug!("Updating client");
    let data = client
        .client()
        .update(
            client::id::equals(data.id),
            vec![
                client::name::set(data.name),
                client::phone::set(data.phone),
                client::email::set(data.email),
                client::cin::set(data.cin),
                client::vat_id::set(data.vat_id),
                client::client_type::set(data.client_type),
                client::address::set(data.address),
                client::city::set(data.city),
                client::zip::set(data.zip),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_client(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting client");
    let data = client.client().delete(client::id::equals(id)).exec().await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src-tauri/src/commands/company.rs -----
use crate::company;
use crate::currency;
use crate::template;
use crate::DbState;
use prisma_client_rust::not;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_companies(
    client: DbState<'_>,
    exclude: Option<i32>,
) -> Result<Vec<company::Data>, QueryError> {
    println!("Getting companies, exluding {:?}", exclude);
    let data = client
        .company()
        .find_many(vec![not![company::id::equals(exclude.unwrap_or(999))]])
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_company(
    client: DbState<'_>,
    id: Option<i32>,
) -> Result<Option<company::Data>, QueryError> {
    client
        .company()
        .find_first(vec![company::id::equals(id.unwrap_or(1))])
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ManageCompanyData {
    name: String,
    cin: String,
    vat_id: Option<String>,
    address: String,
    city: String,
    zip: String,
    phone: Option<String>,
    email: Option<String>,

    bank_account: Option<String>,
    bank_iban: Option<String>,
}

#[tauri::command]
pub async fn create_company(
    client: DbState<'_>,
    data: ManageCompanyData,
) -> Result<i32, QueryError> {
    debug!("Creating company {:?}", data);
    let company = client
        .company()
        .create(
            data.name,
            data.cin,
            data.address,
            data.city,
            data.zip,
            vec![
                company::vat_id::set(data.vat_id),
                company::email::set(data.email),
                company::phone::set(data.phone),
                company::bank_account::set(data.bank_account),
                company::bank_iban::set(data.bank_iban),
            ],
        )
        .exec()
        .await
        .unwrap();

    let currency = client
        .currency()
        .create(
            "Euro".to_string(),
            "EUR".to_string(),
            1.0,
            company::id::equals(company.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    let template = client
        .template()
        .create(
            "Default Invoice".to_string(),
            "<html><body><h1>Invoice</h1></body></html>".to_string(),
            company::id::equals(company.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    let _settings = client
        .settings()
        .create(
            company::id::equals(company.id),
            currency::id::equals(currency.id),
            template::id::equals(template.id),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    Ok(company.id)
}

#[tauri::command]
pub async fn update_company(
    client: DbState<'_>,
    id: i32,
    data: ManageCompanyData,
) -> Result<(), QueryError> {
    debug!("Updating company");
    println!("{:?}", data);
    let data = client
        .company()
        .update(
            company::id::equals(id),
            vec![
                company::name::set(data.name),
                company::cin::set(data.cin),
                company::vat_id::set(data.vat_id),
                company::address::set(data.address),
                company::city::set(data.city),
                company::zip::set(data.zip),
                company::phone::set(data.phone),
                company::email::set(data.email),
                company::bank_account::set(data.bank_account),
                company::bank_iban::set(data.bank_iban),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}


----- src-tauri/src/commands/db.rs -----
use crate::error::CommandResult;
// use crate::migrator::new_client;
use crate::DbState;

// #[specta::specta]
#[tauri::command]
pub async fn check_db(client: DbState<'_>) -> CommandResult<i16> {
    let company_count = client.company().count(vec![]).exec().await;

    info!("Checking DB");
    match company_count {
        Ok(_) => {
            if company_count.unwrap() == 0 {
                return Ok(400);
            }
            return Ok(200);
        }
        Err(_) => Ok(400),
    }
}

// #[specta::specta]
#[tauri::command]
pub async fn migrate_and_populate(client: DbState<'_>) -> CommandResult<()> {
    #[cfg(not(debug_assertions))]
    client._db_push().await?;

    #[cfg(not(debug_assertions))]
    client._migrate_deploy().await.unwrap();

    Ok(())
}


----- src-tauri/src/commands/mod.rs -----
pub mod client;
pub mod company;
pub mod currency;
pub mod db;
pub mod document;
pub mod other;
pub mod settings;
pub mod stats;
pub mod template;


----- src-tauri/src/commands/currency.rs -----
use crate::company;
use crate::currency;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::QueryError;
use serde::Deserialize;

#[tauri::command]
pub async fn get_currencies(
    client: DbState<'_>,
    company_id: i32,
    indicies: Indicies,
) -> Result<Vec<currency::Data>, QueryError> {
    debug!("Getting currencies");
    let data = client
        .currency()
        .find_many(vec![currency::company_id::equals(company_id)])
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await;

    println!("{:?}", data);
    data
}

#[tauri::command]
pub async fn get_currency(
    client: DbState<'_>,
    id: String,
) -> Result<Option<currency::Data>, QueryError> {
    client
        .currency()
        .find_first(vec![currency::id::equals(id)])
        .exec()
        .await
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CurrencyData {
    name: String,
    code: String,
    rate: f64,
}
#[tauri::command]
pub async fn create_currency(
    client: DbState<'_>,
    company_id: i32,
    data: CurrencyData,
) -> Result<(), String> {
    debug!("Creating currency");
    let data = client
        .currency()
        .create(
            data.name,
            data.code,
            data.rate,
            company::id::equals(company_id),
            vec![],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_currency(
    client: DbState<'_>,
    id: String,
    data: CurrencyData,
) -> Result<(), String> {
    debug!("Updating currency");
    let data = client
        .currency()
        .update(
            currency::id::equals(id),
            vec![
                currency::name::set(data.name),
                currency::code::set(data.code),
                currency::rate::set(data.rate),
            ],
        )
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn delete_currency(client: DbState<'_>, id: String) -> Result<(), String> {
    debug!("Deleting currency");
    let data = client
        .currency()
        .delete(currency::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src-tauri/src/commands/document.rs -----
use crate::client;
use crate::commands::settings::update_count;
use crate::company;
use crate::currency;
use crate::document;
use crate::document_item;
use crate::template;
use crate::types::Indicies;
use crate::DbState;
use prisma_client_rust::chrono::{DateTime, FixedOffset};
use prisma_client_rust::Direction;
use prisma_client_rust::QueryError;

use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct DocumentWithPrice {
    id: i32,
    number: String,
    document_type: String,
    client_id: i32,
    template_id: i32,
    currency: String,
    issue_date: DateTime<FixedOffset>,
    due_date: DateTime<FixedOffset>,
    company_id: i32,
    status: String,
    items: Option<Vec<document_item::Data>>,
    total_price: f64,
}

#[tauri::command]
pub async fn get_documents(
    client: DbState<'_>,
    company_id: i32,
    document_type: Option<String>,
    indicies: Indicies,
    client_id: Option<i32>,
) -> Result<Vec<DocumentWithPrice>, QueryError> {
    debug!(
        "Getting documents from {} with type {:?} and indicies {:?}",
        company_id, document_type, indicies
    );

    let mut conditions = vec![document::company_id::equals(company_id)];

    if let Some(client_id) = client_id {
        conditions.push(document::client_id::equals(client_id));
    }
    if let Some(document_type) = document_type {
        conditions.push(document::document_type::equals(document_type));
    }

    let documents = client
        .document()
        .find_many(conditions)
        .order_by(document::id::order(Direction::Desc))
        .with(document::items::fetch(vec![]))
        .with(document::currency::fetch())
        .skip(indicies.skip)
        .take(indicies.take)
        .exec()
        .await?;

    let documents_with_price = documents
        .into_iter()
        .map(|doc| {
            let total_price: f64 = doc
                .items
                .as_ref()
                .unwrap_or(&vec![])
                .iter()
                .map(|item| item.price * item.quantity as f64)
                .sum();
            DocumentWithPrice {
                id: doc.id,
                number: doc.number,
                document_type: doc.document_type,
                client_id: doc.client_id,
                template_id: doc.template_id,
                currency: doc.currency.unwrap().code,
                issue_date: doc.issue_date,
                due_date: doc.due_date,
                company_id: doc.company_id,
                status: doc.status,
                items: doc.items,
                total_price,
            }
        })
        .collect::<Vec<DocumentWithPrice>>();

    Ok(documents_with_price)
}

#[tauri::command]
pub async fn get_document_count(
    client: DbState<'_>,
    document_type: Option<String>,
    client_id: Option<i32>,
) -> Result<i64, QueryError> {
    let mut conditions = vec![];

    if let Some(client_id) = client_id {
        conditions.push(document::client_id::equals(client_id));
    }
    if let Some(document_type) = document_type {
        conditions.push(document::document_type::equals(document_type));
    }

    client.document().count(conditions).exec().await
}

#[tauri::command]
pub async fn get_document(
    client: DbState<'_>,
    id: i32,
) -> Result<Option<document::Data>, QueryError> {
    client
        .document()
        .find_unique(document::id::equals(id))
        .with(document::items::fetch(vec![]))
        .exec()
        .await
}

#[tauri::command]
pub async fn create_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Creating document");
    let res = client
        .document()
        .create(
            data.number,
            data.document_type,
            client::id::equals(data.client_id),
            template::id::equals(data.template_id),
            currency::id::equals(data.currency_id),
            data.issue_date,
            data.due_date,
            company::id::equals(data.company_id),
            vec![document::status::set(data.status)],
        )
        .exec()
        .await;

    if let Some(items) = data.items {
        for item in items.iter() {
            let _ = client
                .document_item()
                .create(
                    document::id::equals(res.as_ref().unwrap().company_id),
                    item.description.clone(),
                    item.quantity,
                    item.price,
                    vec![],
                )
                .exec()
                .await
                .unwrap();
        }
    }

    match res {
        Ok(_) => {
            update_count(client, data.company_id, "Invoice").await;
            Ok(())
        }
        Err(e) => Err(e.to_string()),
    }
}

#[tauri::command]
pub async fn update_document(client: DbState<'_>, data: document::Data) -> Result<(), String> {
    debug!("Updating document");

    // Update the document fields
    let updated_document = client
        .document()
        .update(
            document::id::equals(data.id),
            vec![
                document::number::set(data.number),
                document::document_type::set(data.document_type),
                document::client_id::set(data.client_id),
                document::template_id::set(data.template_id),
                document::currency_id::set(data.currency_id),
                document::issue_date::set(data.issue_date),
                document::due_date::set(data.due_date),
                document::status::set(data.status),
            ],
        )
        .exec()
        .await;

    match updated_document {
        Ok(_) => {
            let _ = client
                .document_item()
                .delete_many(vec![document_item::document_id::equals(data.id)])
                .exec()
                .await;

            if let Some(items) = data.items {
                for item in items.iter() {
                    println!("ITEMS: {:?}", item);
                    let _ = client
                        .document_item()
                        .create(
                            document::id::equals(data.id),
                            item.description.clone(),
                            item.quantity,
                            item.price,
                            vec![],
                        )
                        .exec()
                        .await;
                }
            }

            Ok(())
        }
        Err(e) => {
            error!("Error updating document: {}", e);
            Err(e.to_string())
        }
    }
}

#[tauri::command]
pub async fn delete_document(client: DbState<'_>, id: i32) -> Result<(), String> {
    debug!("Deleting document");
    let data = client
        .document()
        .delete(document::id::equals(id))
        .exec()
        .await;

    match data {
        Ok(_) => Ok(()),
        Err(e) => Err(e.to_string()),
    }
}


----- src-tauri/src/commands/stats.rs -----
use crate::currency;
use crate::document;
use crate::settings;
use crate::DbState;
use prisma_client_rust::chrono::{DateTime, Datelike, Duration, FixedOffset, Local, TimeZone};
use prisma_client_rust::QueryError;

fn get_month_ranges(months: i32) -> Vec<(DateTime<FixedOffset>, DateTime<FixedOffset>)> {
    let today = Local::now();
    let today_naive = today.naive_local().date();
    let mut month_ranges = Vec::new();

    for month_offset in 0..months {
        let target_month = (today_naive.month() as i32 - month_offset - 1).rem_euclid(12) + 1;
        let year_adjustment = (today_naive.month() as i32 - month_offset - 1) / 12;
        let adjusted_year = today_naive.year() + year_adjustment;

        let first_day_of_target_month = today_naive
            .with_year(adjusted_year)
            .unwrap()
            .with_month(target_month as u32)
            .unwrap()
            .with_day(1)
            .unwrap();
        let last_day_of_target_month = first_day_of_target_month
            .with_month((target_month % 12 + 1) as u32)
            .unwrap_or_else(|| {
                first_day_of_target_month
                    .with_year(adjusted_year + 1)
                    .unwrap()
                    .with_month(1)
                    .unwrap()
            })
            - Duration::days(1);

        let start_datetime = FixedOffset::east_opt(0)
            .unwrap()
            .from_utc_datetime(&first_day_of_target_month.and_hms_opt(0, 0, 0).unwrap());
        let end_datetime = FixedOffset::east_opt(0)
            .unwrap()
            .from_utc_datetime(&last_day_of_target_month.and_hms_opt(23, 59, 59).unwrap());

        month_ranges.push((start_datetime, end_datetime));
    }

    // month_ranges.reverse(); // Ensure the months are in ascending order
    month_ranges
}

async fn get_default_currency(client: &DbState<'_>, company_id: i32) -> currency::Data {
    let company_settings = client
        .settings()
        .find_unique(settings::company_id::equals(company_id))
        .with(settings::default_currency::fetch())
        .exec()
        .await
        .unwrap();

    *company_settings.unwrap().default_currency.unwrap()
}
#[tauri::command]
pub async fn get_sales(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<f64>, QueryError> {
    let month_ranges = get_month_ranges(months);
    let default_currency = get_default_currency(&client, company_id).await;
    let mut monthly_sales = Vec::new();

    for (start_date, end_date) in month_ranges {
        let sales = client
            .document()
            .find_many(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("INVOICE".to_string()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .with(document::items::fetch(vec![]))
            .with(document::currency::fetch())
            .exec()
            .await?;

        let total_sales: f64 = sales
            .into_iter()
            .map(|doc| {
                let exchange_rate = if let Some(currency) = doc.currency {
                    if currency.code != "EUR" {
                        currency.rate
                    } else {
                        1.0
                    }
                } else {
                    1.0
                };

                doc.items
                    .unwrap_or_default()
                    .into_iter()
                    .map(|item| {
                        let base_price = item.price * item.quantity as f64 / exchange_rate;
                        (base_price * default_currency.rate).round()
                    })
                    .sum::<f64>()
            })
            .sum();

        monthly_sales.push(total_sales);
    }

    Ok(monthly_sales)
}

#[tauri::command]
pub async fn get_expenses(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<f64>, QueryError> {
    debug!("Getting expenses for company_id: {}", company_id);
    let month_ranges = get_month_ranges(months);
    let default_currency = get_default_currency(&client, company_id).await;
    let mut monthly_expenses = Vec::new();

    for (start_date, end_date) in month_ranges {
        let expenses = client
            .document()
            .find_many(vec![
                document::company_id::equals(company_id),
                document::document_type::equals("RECEIVE".to_string()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .with(document::items::fetch(vec![]))
            .with(document::currency::fetch())
            .exec()
            .await?;

        let total_expenses: f64 = expenses
            .into_iter()
            .map(|doc| {
                let exchange_rate = if let Some(currency) = doc.currency {
                    if currency.code != "EUR" {
                        currency.rate
                    } else {
                        1.0
                    }
                } else {
                    1.0
                };

                doc.items
                    .unwrap_or_default()
                    .into_iter()
                    .map(|item| {
                        let base_price = item.price * item.quantity as f64 / exchange_rate;
                        (base_price * default_currency.rate).round()
                    })
                    .sum::<f64>()
            })
            .sum();

        monthly_expenses.push(total_expenses);
    }

    Ok(monthly_expenses)
}

#[tauri::command]
pub async fn get_sales_and_expenses(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
) -> Result<Vec<(f64, f64)>, QueryError> {
    let sales = get_sales(client.clone(), company_id, months).await?;
    let expenses = get_expenses(client, company_id, months).await?;

    let net_values: Vec<(f64, f64)> = sales.into_iter().zip(expenses.into_iter()).collect();

    Ok(net_values)
}

#[tauri::command]
pub async fn get_documents_stats(
    client: DbState<'_>,
    company_id: i32,
    months: i32,
    document_type: String,
) -> Result<Vec<i64>, QueryError> {
    let month_ranges = get_month_ranges(months);
    let mut monthly_documents = Vec::new();

    for (start_date, end_date) in month_ranges {
        let documents = client
            .document()
            .count(vec![
                document::company_id::equals(company_id),
                document::document_type::equals(document_type.clone()),
                document::issue_date::gte(start_date),
                document::issue_date::lte(end_date),
            ])
            .exec()
            .await
            .unwrap();

        monthly_documents.push(documents);
    }

    Ok(monthly_documents)
}


----- src-tauri/src/commands/template.rs -----


----- src/index.tsx -----
import { lazy } from "solid-js";
import "./styles/index.css";
import "@unocss/reset/tailwind-compat.css";
import "uno.css";

const Overview = lazy(() => import("./screens/Dashboard/pages"));
const Invoices = lazy(() => import("./screens/Dashboard/pages/Sales/Invoices"));
const ManageInvoice = lazy(() => import("./screens/Dashboard/pages/Sales/Invoices/ManageInvoice"));
const ManageProforma = lazy(() => import("./screens/Dashboard/pages/Sales/Proformas/ManageProforma"));
const ManageReceived = lazy(() => import("./screens/Dashboard/pages/Sales/ReceivedInvoices/ManageReceived"));
const ReceivedInvoices = lazy(() => import("./screens/Dashboard/pages/Sales/ReceivedInvoices"));
const Proformas = lazy(() => import("./screens/Dashboard/pages/Sales/Proformas"));
const Templates = lazy(() => import("./screens/Dashboard/pages/Other/Templates"));
const ManageTemplates = lazy(() => import("./screens/Dashboard/pages/Other/Templates/ManageTemplate"));
const Clients = lazy(() => import("./screens/Dashboard/pages/Other/Clients"));
const Print = lazy(() => import("./screens/Print"));
const Currencies = lazy(() => import("./screens/Dashboard/pages/Other/Currencies"));
const ManageCurrency = lazy(() => import("./screens/Dashboard/pages/Other/Currencies/ManageCurrency"));
const ClientDetail = lazy(() => import("./screens/Dashboard/pages/Other/Clients/ClientDetail"));
const ManageClient = lazy(() => import("./screens/Dashboard/pages/Other/Clients/ManageClient"));
const Settings = lazy(() => import("./screens/Dashboard/pages/Settings"));
const Dashboard = lazy(() => import("./screens/Dashboard"));
const Setup = lazy(() => import("./screens/Setup"));
const App = lazy(() => import("./App"));
const Loader = lazy(() => import("./Loader"));

import { render } from "solid-js/web";
import { Theme, getTheme, setTheme } from "./utils/theme";
import { Navigate, Route, Router } from "@solidjs/router";

setTheme(getTheme());

window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (e) => {
  setTheme(e.matches ? Theme.Dark : Theme.Light);
});

render(
  () => (
    <Router root={App}>
      <Route path="/" component={Loader} />
      <Route path="/print/:id" component={Print} />
      <Route path="/setup" component={Setup} />
      <Route path="/dashboard" component={Dashboard}>
        <Route path="/" component={Overview} />
        <Route path="/sales">
          <Route path="/invoices">
            <Route path="/" component={Invoices} />
            <Route path="/new" component={ManageInvoice} />
            <Route path="/:id" component={ManageInvoice} />
          </Route>
          <Route path="/received">
            <Route path="/" component={ReceivedInvoices} />
            <Route path="/new" component={ManageReceived} />
            <Route path="/:id" component={ManageReceived} />
          </Route>
          <Route path="/proformas">
            <Route path="/" component={Proformas} />
            <Route path="/new" component={ManageProforma} />
            <Route path="/:id" component={ManageProforma} />
          </Route>
        </Route>
        <Route path="/other">
          <Route path="/clients">
            <Route path="/" component={Clients} />
            <Route path="/detail/:id" component={ClientDetail} />
            <Route path="/new" component={ManageClient} />
            <Route path="/:id" component={ManageClient} />
          </Route>
          <Route path="/currencies">
            <Route path="/" component={Currencies} />
            <Route path="/new" component={ManageCurrency} />
            <Route path="/:id" component={ManageCurrency} />
          </Route>
          <Route path="/templates">
            <Route path="/" component={Templates} />
            <Route path="/new" component={ManageTemplates} />
            <Route path="/:id" component={ManageTemplates} />
          </Route>
        </Route>
        <Route path="/settings" component={Settings} />
        <Route path="*" component={() => <Navigate href={"/dashboard"} />} />
      </Route>
    </Router>
  ),
  document.getElementById("root") as HTMLElement,
);


----- src/App.tsx -----
import type { ParentComponent } from "solid-js";
import { I18nProvider, locale } from "@/i18n";
import { Toaster } from "solid-toast";
import { StoreProvider } from "@/store";

const App: ParentComponent = (props) => {
  return (
    <I18nProvider locale={locale()}>
      <StoreProvider>{props.children}</StoreProvider>
      <Toaster gutter={8} position="bottom-right" />
    </I18nProvider>
  );
};

export default App;


----- src/Loader.tsx -----
import type { Component } from "solid-js";
import { checkDb } from "@/bindings";
import { useNavigate } from "@solidjs/router";
import LoadingIcon from "./shared/components/LoadingIcon";

const Loader: Component = () => {
  const navigate = useNavigate();

  const startup = async () => {
    const data = await checkDb();
    navigate(data === 200 ? "/dashboard" : "/setup");
  };

  startup();

  return <LoadingIcon />;
};

export default Loader;


----- src/bindings.ts -----
import { invoke } from "@tauri-apps/api/core";
import type { Indicies } from "./screens/Dashboard/components/Table";
import { stateStore } from "./store/services/stateService";

const [state, _] = stateStore;

export async function checkDb() {
  return invoke<200 | 400>("check_db");
}

export type GetDocumentsData = {
  totalPrice: number;
  id: number;
  number: string;
  documentType: "INVOICE" | "PROFORMA" | "RECEIVE";
  clientId: number;
  templateId: number;
  currency: string;
  issueDate: Date;
  status: string;
};

export type GetClientData = {
  id: number;
  name: string;
  email: string;
  phone: string;
};

export enum DocumentType {
  INVOICE = "INVOICE",
  PROFORMA = "PROFORMA",
  RECEIVE = "RECEIVE",
}

export async function getDocuments(indicies: Indicies, documentType?: DocumentType, clientId?: number) {
  return invoke<GetDocumentsData[]>("get_documents", {
    companyId: state.companyId,
    documentType,
    clientId,
    indicies,
  });
}

export type ManageDocumentData = {
  id?: number;
  number: string;
  clientId: number;
  templateId: number;
  documentType: DocumentType;
  currencyId: string;
  issueDate: Date;
  dueDate: Date;
  status: string;
  items: DocumentItem[];
};

export async function getDocument(id: number) {
  return invoke<Document>("get_document", { id });
}

export async function updateDocument(data: ManageDocumentData) {
  return invoke("update_document", { data });
}

export async function deleteDocument(id: number) {
  return invoke("delete_document", { id });
}

export async function createDocument(data: ManageDocumentData) {
  return invoke("create_document", { data: { ...data, companyId: state.companyId } });
}

export async function getClients(indicies: Indicies) {
  return invoke<GetClientData[]>("get_clients", { companyId: state.companyId, indicies });
}

export async function getClient(id: number) {
  return invoke<Client>("get_client", { id });
}
export async function updateClient(data: Client) {
  return invoke<Client>("update_client", { data });
}
export async function deleteClient(id: number) {
  return invoke("delete_client", { id });
}

export async function getCompany(id?: number) {
  return invoke<Company>("get_company", { id: id ? id : state.companyId });
}

export async function createCompany(data: ManageCompanyData) {
  return invoke<number>("create_company", { data });
}

export async function updateCompany(data: ManageCompanyData) {
  return invoke("update_company", { id: state.companyId, data });
}

export async function getDocumentStats(months: number, documentType: DocumentType) {
  return invoke<number[]>("get_documents_stats", { companyId: state.companyId, months, documentType });
}
export async function getSales(months: number) {
  return invoke<number[]>("get_sales", { companyId: state.companyId, months });
}

export async function getExpenses(months: number) {
  return invoke<number[]>("get_expenses", { companyId: state.companyId, months });
}

export async function getSalesAndExpenses(months: number) {
  return invoke<number[]>("get_sales_and_expenses", { companyId: state.companyId, months });
}

export async function getModelCount(
  model: "Invoice" | "Proforma" | "Receive" | "Company" | "Client" | "Template" | "Currency",
) {
  return await invoke<number>("get_model_count", { companyId: state.companyId, model });
}

export async function getDocumentCount(documentType?: DocumentType, clientId?: number) {
  return await invoke<number>("get_document_count", { documentType, clientId });
}

type ManageClientData = {
  id?: number;
  name: string;
  cin: string;
  vatId?: string;
  address: string;
  city: string;
  clientType: "SUPPLIER" | "CUSTOMER" | "BOTH";
  zip: string;
  email?: string;
  phone?: string;
};

export async function createClient(data: ManageClientData) {
  return invoke("create_client", { data: { ...data, companyId: state.companyId } });
}

export async function migrateAndPopulate() {
  return invoke("migrate_and_populate");
}

export async function getCompanies(exclude?: number) {
  return await invoke<Company[]>("get_companies", { exclude });
}

export async function getTemplates(indicies: Indicies, templateType?: "INVOICE" | "PROFORMA" | "RECEIVE") {
  return await invoke<Template[]>("get_templates", { companyId: state.companyId, indicies, templateType });
}

export async function saveTemplate(template: Template) {
  return await invoke<Template>("save_template", { template });
}

export async function getTemplate(id: number) {
  return await invoke<Template>("get_template", { id });
}

export async function deleteTemplate(id: number) {
  return await invoke("delete_template", { id });
}

export type ManageTemplateData = {
  templateType: "INVOICE" | "PROFORMA" | "RECEIVE";
  html: string;
  name: string;
};

export async function createTemplate(template: ManageTemplateData) {
  return await invoke("create_template", { companyId: state.companyId, data: template });
}

export async function updateTemplate(id: number, data: ManageTemplateData) {
  return await invoke("update_template", { id, data });
}

export async function getCurrency(id: string) {
  return await invoke<Currency>("get_currency", { id });
}

export async function getCurrencies(indicies: Indicies) {
  return await invoke<Currency[]>("get_currencies", { companyId: state.companyId, indicies });
}

export async function createCurrency(data: { name: string; code: string; rate: number }) {
  return await invoke("create_currency", { companyId: state.companyId, data });
}

export async function updateCurrency(id: string, data: { name: string; code: string; rate: number }) {
  return await invoke("update_currency", { id, data });
}

export async function deleteCurrency(id: string) {
  return await invoke("delete_currency", { id });
}

export async function getSettings(id?: number) {
  return await invoke<Settings>("get_settings", { companyId: id ? id : state.companyId });
}

export async function updateSettings(data: ManageSettingsData) {
  return await invoke("update_settings", { companyId: state.companyId, data });
}

export async function getPrintDocument(id: number) {
  return await invoke<GetPrintDocumentResult>("get_print_document", { id });
}

export type ManageSettingsData = {
  defaultCurrencyId: string;
  defaultTemplateId: number;
  invoicePrefix: string;
  proformaPrefix: string;
  receivePrefix: string;

  invoiceCounter: number;
  proformaCounter: number;
  receiveCounter: number;
};

export type Settings = {
  id: number;
  defaultCurrency: Currency;
  defaultTemplate: Template;

  invoicePrefix: string;
  invoiceCounter: number;

  proformaPrefix: string;
  proformaCounter: number;

  receivePrefix: string;
  receiveCounter: number;
};

export type Currency = {
  id: string;
  name: string;
  code: string;
  rate: number;
  companyId: number;
};

export type ManageCompanyData = {
  name: string;
  cin: string;
  vatId?: string;
  address: string;
  city: string;
  zip: string;
  phone?: string;
  email?: string;

  bankAccount?: string;
  bankIban?: string;
};

export interface Document {
  id: number;
  number: string;
  clientId: number;
  templateId: number;
  currencyId: string;
  documentType: "INVOICE" | "PROFORMA" | "RECEIVE";
  issueDate: string;
  dueDate: string;
  status: string;
  items: DocumentItem[];
}

export interface DocumentItem {
  id?: number;
  documentId?: number;
  description: string;
  quantity: number;
  price: number;
}

export type Company = {
  id: number;
  name: string;
  cin: string | null;
  vatId: string | null;
  address: string;
  city: string;
  zip: string;
  phone: string | null;
  email: string | null;

  bankAccount: string | null;
  bankIban: string | null;
};

export type Template = {
  id: number;
  templateType: "INVOICE" | "PROFORMA" | "RECEIVE";
  name: string;
  html: string;
  companyId: number;
};

export type Client = {
  id: number;
  name: string;
  cin: string;
  vatId?: string;
  address: string;
  city: string;
  clientType: "SUPPLIER" | "CUSTOMER" | "BOTH";
  zip: string;
  email?: string;
  phone?: string;
  invoices?: Document[];

  bankAccount?: string;
  bankIban?: string;
};

export type GetPrintDocumentResult = {
  id: number;
  number: string;
  documentType: string;
  client: {
    id: number;
    clientType: string;
    name: string;
    cin: string;
    vatId: string | null;
    address: string;
    city: string;
    zip: string;
    email: string | null;
    phone: string | null;
  };
  template: {
    id: number;
    name: string;
    html: string;
    templateType: string;
    companyId: number;
  };
  company: {
    name: string;
    cin: string;
    vatId: string;
    street: string;
    city: string;
    zip: string;
    phoneNumber: string;
    email: string;
  };
  currency: {
    id: string;
    name: string;
    code: string;
    rate: number;
    companyId: number;
  };
  issueDate: Date;
  dueDate: Date;
  status: string;
  items: {
    id: number;
    documentId: number;
    description: string;
    quantity: number;
    price: number;
    // tax: number;
  }[];
  companyId: number;
};


----- src/constants/index.ts -----
export enum LANG {
  EN = "en-US",
  CS = "cs-CZ",
}


----- src/utils/handleDocumentNumber.ts -----
export function generateDocumentNumber(template: string, documentNumber: number): string {
  const currentYear = new Date().getFullYear();
  const shortYear = currentYear % 100;

  let documentString = template.replace(/{FULL_YEAR}/g, currentYear.toString());

  documentString = documentString.replace(/{YEAR}/g, shortYear.toString());

  const documentNumberPlaceholder = documentString.match(/X+/)?.[0];

  if (documentNumberPlaceholder) {
    const placeholderLength = documentNumberPlaceholder.length;

    const paddedDocumentNumber = documentNumber.toString().padStart(placeholderLength, "0");

    documentString = documentString.replace(/X+/, paddedDocumentNumber);
  } else {
    documentString += documentNumber;
  }

  return documentString;
}


----- src/utils/savePDF.ts -----
import { Window } from "@tauri-apps/api/window";
import { Webview } from "@tauri-apps/api/webview";

export async function getInitializedPrintWindow(id: number) {
  const appWindow = new Window("document", {
    visible: true,
    decorations: true,
    title: "Document",
    width: 200,
    height: 200,
  });
  const webview = new Webview(appWindow, "documentweb", {
    url: `/print/${id}`,
    width: 2100,
    height: 2970,
    transparent: true,
    x: 0,
    y: 0,
  });
  webview.once("tauri://error", (e) => {
    // an error happened creating the webview
    console.error(e);
  });
}


----- src/utils/getDataByCIN.ts -----
export async function getDataByCIN(ico: string) {
  const response = await fetch(`https://ares.gov.cz/ekonomicke-subjekty-v-be/rest/ekonomicke-subjekty/${ico}`);
  const data = await response.json();
  console.log(data);

  const psc: string = data.sidlo.psc.toString();

  return {
    company: data.obchodniJmeno,
    address: `${data.sidlo.nazevUlice || data.sidlo.nazevObce} ${data.sidlo.cisloDomovni}`,
    city: data.sidlo.nazevObce,
    // zip: data.sidlo.psc,
    zip: `${psc.slice(0, 3)} ${psc.slice(3, 6)}`,
    dic: data.dic,
  };
}


----- src/utils/theme.ts -----
export enum Theme {
  Light = "light",
  Dark = "dark",
}

export const setTheme = (theme: Theme) => {
  if (theme === Theme.Dark) {
    document.documentElement.classList.add("dark");
  } else {
    document.documentElement.classList.remove("dark");
  }
};

export const getTheme = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches ? Theme.Dark : Theme.Light;
};


----- src/shared/components/Form/index.tsx -----
import type { ParentComponent } from "solid-js";

// div beacuse form causes issues with dropdown menu
const Form: ParentComponent<{ class?: string }> = (props) => {
  return <div class={`w-full flex flex-col gap-8 ${props.class}`}>{props.children}</div>;
};
export default Form;


----- src/shared/components/Form/Section.tsx -----
import { Show, type ParentComponent } from "solid-js";

const Section: ParentComponent<{ title?: string; columns?: number }> = (props) => {
  return (
    <div>
      <Show when={props.title}>
        <h2 class="text-primary text-sm font-semibold pb-2">{props.title}</h2>
      </Show>
      <div class="grid gap-4" style={{ "grid-template-columns": `repeat(${props.columns || 2}, 1fr)` }}>
        {props.children}
      </div>
    </div>
  );
};

export default Section;


----- src/shared/components/Form/SearchDropdown.tsx -----
import type { Component, JSX } from "solid-js";
import { For, Show, createEffect, createSignal } from "solid-js";
import { Combobox, ComboboxInput, ComboboxOption, ComboboxOptions, DisclosureStateChild, Transition } from "terracotta";
import { TbSelector } from "solid-icons/tb";
import { FiCheck } from "solid-icons/fi";
import type { ValidationError } from "@tanstack/solid-form";
import { useI18n } from "@/i18n";

interface ComboboxItem {
  id: number | string;
  label: string;
}

interface ComboboxProps {
  data: ComboboxItem[];
  onSelect: (value: ComboboxItem) => void;
  label: string;
  defaultValueId?: number | string;
  errors?: ValidationError[];
}

const SearchDropdown: Component<ComboboxProps> = (props) => {
  const [selected, setSelected] = createSignal<ComboboxItem | undefined>(undefined);
  const [t] = useI18n();

  createEffect(() => {
    if (props.defaultValueId) {
      setSelected(props.data.find((item) => item.id === props.defaultValueId));
    } else {
      setSelected(undefined);
    }
  }, [props.defaultValueId]);

  const handleSelect = (value: ComboboxItem | undefined) => {
    if (!value) return;
    setSelected(value);
    props.onSelect(value);
  };

  const matchBy = (item: ComboboxItem, query: string): boolean => {
    return item.label.toLowerCase().includes(query.toLowerCase());
  };

  return (
    <div class="flex flex-col gap-1">
      <span class="text-xs text-secondary">{props.label}</span>
      <Combobox<ComboboxItem>
        defaultOpen={false}
        // @ts-expect-error - Combobox expects a string
        value={selected()}
        onSelectChange={handleSelect}
        matchBy={matchBy}
        class="relative"
      >
        <ComboboxInput
          class="z-1 relative w-full py-1.5 pl-3 pr-10 text-left bg-element border-default border-1 rounded-md h-9 cursor-default focus:outline-none text-sm"
          classList={{
            "border-danger ": props.errors ? props.errors.length > 0 : false,
            "border-default": !props.errors || props.errors.length === 0,
          }}
          placeholder={t("components.dropdownSelect")}
          value={selected()?.label ?? ""}
        />
        <span class="absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none ">
          <TbSelector class="w-5 h-5 text-primary" aria-hidden="true" />
        </span>
        <DisclosureStateChild>
          {({ isOpen }): JSX.Element => (
            <Transition
              show={isOpen()}
              enter="transition ease-in duration-100"
              enterFrom="opacity-0"
              enterTo="opacity-100"
              leave="transition ease-out duration-100"
              leaveFrom="opacity-100"
              leaveTo="opacity-0"
            >
              <ComboboxOptions class="z-100 absolute w-full py-1 mt-1 overflow-auto text-base bg-element border-default border-1 rounded-md shadow-lg max-h-60 focus:outline-none sm:text-sm">
                <For each={props.data}>
                  {(item): JSX.Element => (
                    <ComboboxOption class="focus:outline-none group z-99" value={item}>
                      {({ isActive, matches }): JSX.Element => (
                        <div
                          classList={{
                            "bg-secondary": isActive(),
                            "cursor-default select-none relative py-2 pl-10 pr-4": true,
                            hidden: !matches(),
                          }}
                        >
                          <span
                            classList={{
                              "font-medium": selected()?.id === item.id,
                              "font-normal": selected()?.id !== item.id,
                              "block truncate": true,
                            }}
                          >
                            {item.label}
                          </span>
                          {selected()?.id === item.id ? (
                            <span
                              classList={{
                                "text-primary": true,
                                "absolute inset-y-0 left-0 flex items-center pl-3": true,
                              }}
                            >
                              <FiCheck class="w-5 h-5" />
                            </span>
                          ) : null}
                        </div>
                      )}
                    </ComboboxOption>
                  )}
                </For>
              </ComboboxOptions>
            </Transition>
          )}
        </DisclosureStateChild>
      </Combobox>
      <Show when={props.errors}>
        <For each={props.errors}>{(error) => <span class="text-xs text-danger">{error?.toString()}</span>}</For>
      </Show>
    </div>
  );
};

export default SearchDropdown;


----- src/shared/components/Form/Dropdown.tsx -----
import type { Component, JSX } from "solid-js";
import { For, createEffect, createSignal } from "solid-js";
import { DisclosureStateChild, Listbox, ListboxButton, ListboxOption, ListboxOptions, Transition } from "terracotta";
import { TbSelector } from "solid-icons/tb";
import { FiCheck } from "solid-icons/fi";

interface DropdownItem {
  id: number | string;
  label: string;
}

interface DropdownProps {
  data: DropdownItem[];
  onSelect: (value: DropdownItem) => void;
  label: string;
  defaultValueId?: number | string;
}

const Dropdown: Component<DropdownProps> = (props) => {
  const [selected, setSelected] = createSignal<DropdownItem>(props.data[0]);

  createEffect(() => {
    if (props.defaultValueId) setSelected(props.data.find((item) => item.id === props.defaultValueId) || props.data[0]);
  }, [props.defaultValueId]);

  const handleSelect = (value: DropdownItem | undefined) => {
    if (!value) return;
    setSelected(value);
    props.onSelect(value);
  };

  return (
    <div class="flex flex-col gap-1 z-auto">
      <span class="text-xs text-secondary">{props.label}</span>
      <Listbox defaultOpen={false} value={selected()} onSelectChange={handleSelect} class="relative">
        <ListboxButton class="relative w-full py-1.5 pl-3 pr-10 text-left bg-element border-default border-1 rounded-md h-9 cursor-default focus:outline-none text-sm">
          <span class="block truncate">{selected().label}</span>
          <span class="absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none">
            <TbSelector class="w-5 h-5 text-primary" aria-hidden="true" />
          </span>
        </ListboxButton>
        <DisclosureStateChild>
          {({ isOpen }): JSX.Element => (
            <Transition
              show={isOpen()}
              enter="transition ease-in duration-100"
              enterFrom="opacity-0"
              enterTo="opacity-100"
              leave="transition ease-out duration-100"
              leaveFrom="opacity-100"
              leaveTo="opacity-0"
            >
              <ListboxOptions
                unmount={false}
                class="absolute w-full py-1 mt-1  overflow-auto text-base bg-element border-default border-1 rounded-md shadow-lg max-h-60 focus:outline-none sm:text-sm"
              >
                <For each={props.data}>
                  {(item): JSX.Element => (
                    <ListboxOption class="focus:outline-none group" value={item}>
                      {({ isActive, isSelected }): JSX.Element => (
                        <div
                          classList={{
                            "bg-secondary": isActive(),
                            "cursor-default select-none relative py-2 pl-10 pr-4": true,
                          }}
                        >
                          <span
                            classList={{
                              "font-medium": isSelected(),
                              "font-normal": !isSelected(),
                              "block truncate": true,
                            }}
                          >
                            {item.label}
                          </span>
                          {isSelected() ? (
                            <span
                              classList={{
                                "text-primary": true,
                                "absolute inset-y-0 left-0 flex items-center pl-3": true,
                              }}
                            >
                              <FiCheck class="w-5 h-5" />
                            </span>
                          ) : null}
                        </div>
                      )}
                    </ListboxOption>
                  )}
                </For>
              </ListboxOptions>
            </Transition>
          )}
        </DisclosureStateChild>
      </Listbox>
    </div>
  );
};

export default Dropdown;


----- src/shared/components/Form/Table.tsx -----
import type { Component } from "solid-js";

const Table: Component<{}> = (props) => {
  return <div></div>;
};

export default Table;


----- src/shared/components/Form/Input.tsx -----
import type { ValidationError } from "@tanstack/solid-form";
import { For, Show, type Component } from "solid-js";

type TextInputProps = {
  type: "text" | "date" | "email" | "tel";
  onChange: (value: string) => void;
  label: string;
  placeholder?: string;
  defaultValue?: string;
  errors?: ValidationError[];
  float?: boolean;
  class?: string;
};

type NumberInputProps = {
  type: "number";
  onChange: (value: number) => void;
  label: string;
  placeholder?: string;
  defaultValue?: number;
  errors?: ValidationError[];
  float?: boolean;
  class?: string;
};

type InputProps = TextInputProps | NumberInputProps;

const Input: Component<InputProps> = (props) => {
  const handleInput = (e: Event) => {
    const value = (e.target as HTMLInputElement).value;
    if (props.type === "number") {
      props.onChange(Number(value) as never);
    } else {
      props.onChange(value as never);
    }
  };

  return (
    <label class={`flex flex-col gap-1 ${props.class}`}>
      <span class="text-xs text-secondary">{props.label}</span>
      <input
        type={props.type}
        class="w-full px-2 py-1.5 border rounded-md bg-element text-sm text-primary transition-all h-9"
        classList={{
          "border-danger ": props.errors ? props.errors.length > 0 : false,
          "border-default": !props.errors || props.errors.length === 0,
        }}
        onInput={handleInput}
        step={props.float ? 0.1 : undefined}
        placeholder={props.placeholder}
        value={props.defaultValue ? props.defaultValue : ""}
      />
      <Show when={props.errors}>
        <For each={props.errors}>{(error) => <span class="text-xs text-danger">{error?.toString()}</span>}</For>
      </Show>
    </label>
  );
};

export default Input;


----- src/shared/components/Popover.tsx -----
import { type ParentComponent, Show } from "solid-js";
import { Motion } from "solid-motionone";

interface IPopoverProps {
  title: string;
  onClose: () => void;
  show: boolean;
}

const Popover: ParentComponent<IPopoverProps> = (props) => {
  return (
    <Show when={props.show}>
      <Motion.div
        transition={{ duration: 0.3, easing: "ease-in-out" }}
        class="fixed top-0 left-0 w-screen h-screen backdrop-blur-lg transition-all z-[99] bg-black/30 flex justify-center items-center"
        onClick={(e: MouseEvent) => {
          if (e.target === e.currentTarget) {
            props.onClose();
          }
        }}
        style={{ display: props.show ? "flex" : "none" }}
      >
        <Motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.8, opacity: 0 }}
          transition={{ duration: 0.3, easing: "ease-in-out" }}
          class="bg-white p-8 w-[90%] sm:w-[80%] md:w-[60%] lg:w-[45%] rounded-xl max-h-[80%] overflow-x-auto shadow-2xl"
        >
          <div class="flex justify-between items-center mb-4">
            <h1 class="text-2xl font-bold text-gray-800 tracking-tight">{props.title}</h1>
            <button
              onClick={props.onClose}
              class="text-gray-500 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              type="button"
              aria-label="Close"
            >
              <svg
                class="w-6 h-6"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <title>a</title>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          <hr class="border-gray-200 mb-6" />

          <div class="text-gray-700 text-base leading-relaxed">{props.children}</div>
        </Motion.div>
      </Motion.div>
    </Show>
  );
};

export default Popover;


----- src/shared/components/Info.tsx -----
import { FiInfo } from "solid-icons/fi";
import type { ParentComponent } from "solid-js";

const Info: ParentComponent<{
  onClick?: (e: MouseEvent) => void;
}> = (props) => {
  return (
    <div
      classList={{ "flex gap-1.5 text-info text-xs items-center": true, "cursor-pointer": Boolean(props.onClick) }}
      onClick={props.onClick}
    >
      <FiInfo />
      {props.children}
    </div>
  );
};

export default Info;


----- src/shared/components/LoadingIcon.tsx -----
import { FiLoader } from "solid-icons/fi";
import type { Component } from "solid-js";

const LoadingIcon: Component = () => {
  return (
    <div class="absolute w-screen h-screen top-0 left-0 flex items-center justify-center transition-all bg-black/20">
      <FiLoader class="animate-spin text-primary w-6 h-6 text-secondary" />
    </div>
  );
};

export default LoadingIcon;


----- src/shared/components/Search.tsx -----
import { useI18n } from "@/i18n";
import { FiSearch } from "solid-icons/fi";
import type { JSX, ParentComponent } from "solid-js";

interface SearchProps {
  onInput: JSX.EventHandler<HTMLInputElement, InputEvent>;
}

export const Search: ParentComponent<SearchProps> = (props) => {
  const [t] = useI18n();

  return (
    <div class="rounded-md overflow-hidden inline-flex justify-between items-center dark:bg-#353536 bg-#d1d1d1 text-base font-light ring-default focus-within:ring-3 ">
      <FiSearch class="mx-2 my-1 text-primary" />
      <input
        type="search"
        onInput={props.onInput}
        placeholder={t("components.search")}
        class="appearance-none outline-none flex-grow text-sm dark-(bg-#353536)  bg-#d1d1d1 text-primary placeholder:text-opaque-3"
      />
    </div>
  );
};


----- src/shared/components/Menu/Hr.tsx -----
import type { Component } from "solid-js";

export const Hr: Component<{ class?: string }> = (props) => {
  return <hr class={`w-full border-default opacity-30 ${props.class}`} />;
};


----- src/shared/components/Menu/InputList.tsx -----
import { ParentComponent } from "solid-js";

const InputList: ParentComponent = (props) => {
  //   TODO: margin l r
  return (
    <div class="flex items-center ">
      <div class="flex flex-col gap-4 w-full ">{props.children}</div>
    </div>
  );
};

export default InputList;


----- src/shared/components/Menu/Input.tsx -----
import { FiInfo } from "solid-icons/fi";
import { type Component, Show, createSignal } from "solid-js";

const Input: Component<{
  id: string;
  label?: string;
  placeholder?: string;
  info?: string;
  class?: string;
  onChange?: (e: Event) => void;
}> = (props) => {
  const [showInfo, setShowInfo] = createSignal(false);

  return (
    <div class={`flex flex-row items-center justify-right ${props.class}`}>
      <label for={props.id} class="inline-block text-sm font-medium text-neutral-300">
        {props.label}
      </label>
      <input
        id={props.id}
        type="text"
        classList={{
          "ml-5 w-60 h-8 py-1 text-sm border text-primary border-neutral-900 rounded-md shadow-inner bg-neutral-900 px-2 focus:outline-none focus:border-primary bg-primary": true,
          "mr-6": !props.info,
        }}
        placeholder={props.placeholder}
        onChange={props.onChange}
      />
      <Show when={props.info}>
        <div
          onMouseEnter={() => setShowInfo(true)}
          onMouseLeave={() => setShowInfo(false)}
          class="relative ml-3 w-3 h-3"
        >
          <FiInfo class="text-white w-4 h-4" />
          <Show when={showInfo()}>
            <div class="absolute top-(-2) left-(-2) bg-neutral-900 text-primary p-2 rounded-md shadow-md text-sm w-50 flex gap-2 items-baseline justify-start ">
              <FiInfo class="text-white w-4 h-4" />

              {props.info}
            </div>
          </Show>
        </div>
      </Show>
    </div>
  );
};

export default Input;


----- src/shared/components/Badge.tsx -----
// import { FiInfo } from "solid-icons/fi";
import type { ParentComponent } from "solid-js";

const Badge: ParentComponent<{
  color: "success" | "danger" | "info" | "warning";
}> = (props) => {
  return (
    <div
      classList={{
        "flex gap-1.5 text-xs items-center py-0.5 px-1 rounded ": true,
        "text-success bg-success": props.color === "success",
        "text-danger bg-danger ": props.color === "danger",
        "text-info": props.color === "info",
        "text-warning": props.color === "warning",
      }}
    >
      {/* <FiInfo /> */}
      {props.children}
    </div>
  );
};

export default Badge;


----- src/shared/components/Button.tsx -----
import type { ParentComponent } from "solid-js";

export const Button: ParentComponent<{ onClick?: (e: MouseEvent) => void; class?: string }> = (props) => {
  return (
    <button
      class={
        "rounded py-0.5 px-2 text-sm shadow-md shadow-default/20 text-white bg-default max-w-30 bg-gradient-to-b from-transparent-white to-transparent active:from-transparent-black"
      }
      type="button"
      onClick={props.onClick}
    >
      {props.children}
    </button>
  );
};

export default Button;


----- src/shared/components/PdfRenderer.tsx -----
import { type Component, createSignal, onMount } from "solid-js";
import { Liquid } from "liquidjs";
import type { GetPrintDocumentResult } from "@/bindings";

interface PdfRendererProps {
  data: GetPrintDocumentResult | undefined;
}

const PdfRenderer: Component<PdfRendererProps> = (props) => {
  const [pdfContent, setPdfContent] = createSignal("");

  onMount(async () => {
    const { data } = props;
    console.log(data);
    if (!data) {
      return;
    }

    const engine = new Liquid();
    const renderedContent = await engine.parseAndRender(data.template.html, data);

    setPdfContent(renderedContent);
  });

  return <div class="bg-white text-black w-210mm h-297mm " innerHTML={pdfContent()} />;
};

export default PdfRenderer;


----- src/shared/components/Toast.tsx -----
import type { ParentComponent } from "solid-js";
import toast, { type Toast } from "solid-toast";

// TODO
const CustomToast: ParentComponent<{ t: Toast }> = (props) => {
  return (
    <div class="px-6 py-2 pr-12 bg-secondary text-primary rounded-lg shadow-md relative">
      {props.children}
      <button
        type="button"
        class="bg-default flex justify-center top-1/2 -translate-y-1/2 items-center w-6 h-6 right-2.5 absolute rounded-full"
        onClick={() => toast.dismiss(props.t.id)}
      >
        &times;
      </button>
    </div>
  );
};
export default CustomToast;


----- src/shared/components/SegmentedControl.tsx -----
import { For, type ParentComponent, createSignal } from "solid-js";

interface SegmentedControlProps {
  options: {
    id: string;
    label: string;
  }[];
  onChange?: (value: string) => void;
}

export const SegmentedControl: ParentComponent<SegmentedControlProps> = (props) => {
  const [selectedValue, setSelectedValue] = createSignal(props.options[0]?.id || "");

  const handleChange = (event: Event) => {
    const target = event.target as HTMLInputElement;
    setSelectedValue(target.value);
    props.onChange?.(target.value);
  };

  return (
    <fieldset class="text-primary relative p-[1px] h-auto flex items-stretch overflow-hidden rounded-[6px] shadow-segmented-control bg-fills-opaque-5 dark:bg-[#1C1C1F] ">
      <For each={props.options}>
        {(option) => (
          <input
            id={option.id}
            type="radio"
            value={option.id}
            name="segmented-control"
            checked={selectedValue() === option.id}
            onChange={handleChange}
            class="transition-all appearance-none relative h-[22px] flex-1 rounded dark:(checked:bg-[#636366] active:bg-[#636366] active:opacity-100) active-(opacity-50 bg-white) checked-(bg-white shadow-sm before:hidden) first:before:hidden before:absolute before:z-[-1] before:left-[-1px] before:top-[5px] before:w-[1px] before:h-[10px] before:bg-fills-opaque-4 before:rounded"
          />
        )}
      </For>

      <div class="absolute inset-0 w-full h-full flex items-center">
        <For each={props.options}>
          {(option) => <label for={option.id} class="flex-1 text-center text-sm" textContent={option.label} />}
        </For>
      </div>
    </fieldset>
  );
};


----- src/screens/Setup/index.tsx -----
import { locale, setLocale, useI18n } from "@/i18n";
import { createSignal, type Component, Show, onMount } from "solid-js";
import ProgressDots from "./components/Progress";
import { type ManageCompanyData, createCompany, migrateAndPopulate } from "@/bindings";
import { LANG } from "@/constants";
import { open } from "@tauri-apps/plugin-shell";
import { useNavigate } from "@solidjs/router";
import { createForm } from "@tanstack/solid-form";
import { zodValidator } from "@tanstack/zod-form-adapter";
import Form from "@/shared/components/Form";
import Input from "@/shared/components/Form/Input";
import LanguageBox from "./components/LanguageBox";
import Button from "@/shared/components/Button";
import { Title } from "./components/Title";
import { z } from "zod";
import toast from "solid-toast";
import Section from "@/shared/components/Form/Section";
import { useSelector } from "@/store";

const SetupWizard: Component = () => {
  const [t] = useI18n();
  const [currentStep, setCurrentStep] = createSignal(0);
  const navigate = useNavigate();
  const updateState = useSelector((state) => state.stateService.updateState);

  const form = createForm(() => ({
    defaultValues: {
      name: "",
      cin: "",
      vatId: undefined,
      email: undefined,
      phone: undefined,
      address: "",
      city: "",
      zip: "",
      bankAccount: undefined,
      bankIban: undefined,
    } as ManageCompanyData,
    validatorAdapter: zodValidator,
    onSubmitInvalid: (e) => {
      console.log("invalid", e.formApi.state.errors);
    },
    onSubmit: async (userData) => {
      try {
        const result = await createCompany(userData.value);

        updateState({ companyId: result });
        toast.success(t("setup.company_created"));
        navigate("/");
      } catch (error) {
        console.error("Error creating company:", error);
        toast.error(t("setup.error_creating_ompany"));
      }
    },
  }));

  onMount(async () => {
    await migrateAndPopulate();
  });

  return (
    <div class="flex justify-center items-end w-screen h-screen px-3 pt-37px pb-3" data-tauri-drag-region>
      <div class="absolute top-0 left-0 w-full bg-transparent h-37px z-30 " data-tauri-drag-region>
        <ProgressDots count={3} active={currentStep()} />
      </div>

      <div class="w-full h-full bg-primary rounded-xl drop-shadow-xl relative overflow-auto mx-auto p-8 px-15% lg:px-23%">
        <Show when={currentStep() === 0}>
          <div class="flex justify-center items-center h-full flex-col gap-8">
            <Title>{t("setup.welcome")}</Title>
            <Button onClick={() => setCurrentStep(1)}>{t("setup.get_started")}</Button>
          </div>
        </Show>

        <Show when={currentStep() === 1}>
          <div class="flex justify-center items-center h-full flex-col gap-8">
            <Title>{t("setup.step1.select_language")}</Title>
            <div>
              <div class="flex gap-4">
                <LanguageBox onClick={() => setLocale(LANG.CS)} active={locale() === LANG.CS}>
                  🇨🇿
                </LanguageBox>
                <LanguageBox onClick={() => setLocale(LANG.EN)} active={locale() === LANG.EN}>
                  🇬🇧
                </LanguageBox>
              </div>
              <p
                class="text-primary text-center cursor-pointer text-lightgrey mt-2"
                onClick={() => open("https://github.com/dfrnoch/accounting")}
              >
                {t("setup.step1.improve")}
              </p>
            </div>
            <Button onClick={() => setCurrentStep(2)}>{t("setup.continue")}</Button>
          </div>
        </Show>

        <Show when={currentStep() === 2}>
          <Form>
            <Title>{t("setup.step2.create_company")}</Title>
            <Section title={t("setup.step2.sections.details")}>
              <form.Field
                name="name"
                validators={{ onChange: z.string().min(2).max(100), onChangeAsyncDebounceMs: 500 }}
              >
                {(field) => (
                  <Input
                    type="text"
                    placeholder="Acme Inc"
                    label={t("setup.step2.company_name")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
              <form.Field name="cin" validators={{ onChange: z.string().min(2), onChangeAsyncDebounceMs: 500 }}>
                {(field) => (
                  <Input
                    type="text"
                    placeholder="12345678"
                    label={t("setup.step2.CIN")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
              <form.Field name="vatId" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
                {(field) => (
                  <Input
                    type="text"
                    placeholder="CZ12345678"
                    label={t("setup.step2.vatID")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
            </Section>
            <Section title={t("setup.step2.sections.bank")}>
              <form.Field
                name="bankAccount"
                validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}
              >
                {(field) => (
                  <Input
                    type="text"
                    placeholder="123456789/1234"
                    label={t("setup.step2.account")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
              <form.Field
                name="bankIban"
                validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}
              >
                {(field) => (
                  <Input
                    type="text"
                    label={t("setup.step2.iban")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
            </Section>
            <Section title={t("setup.step2.sections.contact")}>
              <form.Field
                name="address"
                validators={{ onChange: z.string().min(2).max(100), onChangeAsyncDebounceMs: 500 }}
              >
                {(field) => (
                  <Input
                    type="text"
                    placeholder="123 Main St"
                    label={t("setup.step2.street")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
              <form.Field name="city" validators={{ onChange: z.string(), onChangeAsyncDebounceMs: 500 }}>
                {(field) => (
                  <Input
                    type="text"
                    placeholder="Springfield"
                    label={t("setup.step2.city")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
              <form.Field name="zip" validators={{ onChange: z.string(), onChangeAsyncDebounceMs: 500 }}>
                {(field) => (
                  <Input
                    type="text"
                    placeholder="12345"
                    label={t("setup.step2.zip")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
              <form.Field
                name="email"
                validators={{
                  onChange: z.string().email().optional(),
                  onChangeAsyncDebounceMs: 500,
                }}
              >
                {(field) => (
                  <Input
                    type="email"
                    placeholder="john@acme.com"
                    label={t("setup.step2.email")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
              <form.Field name="phone" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
                {(field) => (
                  <Input
                    type="tel"
                    placeholder="+420 123 456 789"
                    label={t("setup.step2.phone")}
                    defaultValue={field().state.value}
                    onChange={(data) => field().handleChange(data)}
                    errors={field().state.meta.touchedErrors}
                  />
                )}
              </form.Field>
            </Section>
            <Button class="my-8" onClick={form.handleSubmit}>
              {t("setup.finalize")}
            </Button>
          </Form>
        </Show>
      </div>
    </div>
  );
};

export default SetupWizard;


----- src/screens/Setup/components/Title.tsx -----
import type { ParentComponent } from "solid-js";

export const Title: ParentComponent<{ class?: string }> = (props) => {
  return <h1 class={`text-2xl font-semibold text-primary ${props.class}`}>{props.children}</h1>;
};


----- src/screens/Setup/components/Progress.tsx -----
import { type Component, For } from "solid-js";

// https://macos-tailwind.netlify.app/?path=/docs/controls-progress-bar--docs
const ProgressDots: Component<{ count: number; active: number }> = (props) => {
  return (
    <div class="absolute w-full h-10 top-0 left-0 flex gap-4 items-center justify-center" data-tauri-drag-region>
      <For each={Array(props.count).fill(0)}>
        {(_, index) => (
          <div
            class={`transition rounded-full bg-black dark:bg-white ${
              props.active === index() ? "w-2.5 h-2.5 opacity-100 " : "opacity-30 w-2 h-2"
            }`}
          />
        )}
      </For>
    </div>
  );
};

export default ProgressDots;


----- src/screens/Setup/components/LanguageBox.tsx -----
import type { ParentComponent } from "solid-js";

const LangaugeBox: ParentComponent<{ onClick: () => void; active?: boolean }> = (props) => {
  return (
    <div
      onclick={props.onClick}
      classList={{
        "py-4 text-3xl border text-primary border-neutral-900 rounded-md shadow-inner bg-neutral-900 px-10  transition cursor-pointer": true,
        "bg-pimary": props.active,
        "bg-primary": !props.active,
      }}
    >
      {props.children}
    </div>
  );
};

export default LangaugeBox;


----- src/screens/Print/index.tsx -----
import { getPrintDocument } from "@/bindings";
import PdfRenderer from "@/shared/components/PdfRenderer";
import { useParams } from "@solidjs/router";
import { Show, Suspense, createResource, type Component } from "solid-js";

const Print: Component = () => {
  const params = useParams<{ readonly id: string }>();

  const [data] = createResource(Number(params.id), getPrintDocument);

  setTimeout(() => {
    window.print();
  }, 1000);

  return (
    <Suspense fallback="Loading...">
      <Show when={!data.loading}>
        <PdfRenderer data={data()} />
      </Show>
    </Suspense>
  );
};

export default Print;


----- src/screens/Dashboard/index.tsx -----
import type { ParentComponent } from "solid-js";
import { Show, Suspense, createResource } from "solid-js";
import { getCompany } from "../../bindings";
import Sidebar from "./components/Sidebar";
import { useNavigate } from "@solidjs/router";
import toast from "solid-toast";
import { useSelector } from "@/store";
import LoadingIcon from "@/shared/components/LoadingIcon";

const Dashboard: ParentComponent = (props) => {
  const navigate = useNavigate();
  const state = useSelector((state) => state.stateService.state);

  const companyService = useSelector((state) => state.companyService);
  const settingsService = useSelector((state) => state.settingsService);

  const fetchCompany = async (companyId: number) => {
    if (companyId === 0) {
      navigate("/setup");
      return;
    }

    const companyData = await getCompany(companyId);
    if (!companyData) {
      navigate("/setup");
      toast.error("Company not found");
      return;
    }

    await companyService.updateCompany();
    await settingsService.updateSettings();

    return companyData;
  };

  const [company] = createResource(state.companyId, fetchCompany);

  return (
    <div class="flex flex-row items-start w-screen">
      <Suspense fallback={<LoadingIcon />}>
        <Show when={company()}>
          <Sidebar />
          <div class="overflow-y-auto mx-auto w-full h-screen pt-40px no-scrollbar bg-primary text-primary"
          classList={{
            "rounded-tl-xl": state.platform == "windows",
          }}
          >
            {props.children}
          </div>
        </Show>
      </Suspense>
    </div>
  );
};

export default Dashboard;


----- src/screens/Dashboard/components/Sidebar/index.tsx -----
import { type Component, For, type JSX, createSignal, onMount } from "solid-js";
import SidebarButton from "./Button";
import SidebarSection from "./Section";
import { useI18n } from "@/i18n";
import {
  FiCheck,
  FiClipboard,
  FiDollarSign,
  FiFileMinus,
  FiFileText,
  FiHome,
  FiInbox,
  FiPlus,
  FiSettings,
  FiUsers,
} from "solid-icons/fi";
import { Hr } from "@/shared/components/Menu/Hr";
import { DisclosureStateChild, Listbox, ListboxButton, ListboxOption, ListboxOptions, Transition } from "terracotta";
import { type Company, getCompanies } from "@/bindings";
import { useNavigate } from "@solidjs/router";
import toast from "solid-toast";
import { useSelector } from "@/store";

interface SidebarButtonData {
  target: string;
  icon: JSX.Element;
  label: string;
}

interface SidebarSectionData {
  title: string;
  buttons: SidebarButtonData[];
}

const Sidebar: Component = () => {
  const [t] = useI18n();
  const navigate = useNavigate();
  const company = useSelector((state) => state.companyService.company);
  const stateService = useSelector((state) => state.stateService);

  const [companies, setCompanies] = createSignal<Company[]>([]);
  const [selected, setSelected] = createSignal<Company>(company);

  onMount(async () => {
    const data = await getCompanies(stateService.state.companyId || undefined);
    setCompanies([company, ...data]);
  });

  const setCompany = (company: Company) => {
    stateService.updateState({ companyId: company.id });
    toast.success("Switched company");
    navigate("/");
  };

  const sidebarSections: SidebarSectionData[] = [
    {
      title: t("sidebar.section.sales"),
      buttons: [
        { target: "/dashboard/sales/invoices", icon: <FiFileText />, label: t("sidebar.button.invoices") },
        { target: "/dashboard/sales/received", icon: <FiFileMinus />, label: t("sidebar.button.receivedInvoices") },
        { target: "/dashboard/sales/proformas", icon: <FiInbox />, label: t("sidebar.button.proformas") },
      ],
    },
    {
      title: t("sidebar.section.other"),
      buttons: [
        { target: "/dashboard/other/clients", icon: <FiUsers />, label: t("sidebar.button.clients") },
        { target: "/dashboard/other/templates", icon: <FiClipboard />, label: t("sidebar.button.templates") },
        { target: "/dashboard/other/currencies", icon: <FiDollarSign />, label: t("sidebar.button.currencies") },
      ],
    },
  ];

  return (
    <div
      class="text-primary relative flex h-screen w-1/5 min-w-[200px] shrink-0 flex-col justify-between border-zinc-400/70 px-2.5 pb-4 lg:max-w-[220px] lg:px-4 dark:border-black/90"
      classList={{
        "pt-14 border-r bg-white/50 dark:bg-black/20": stateService.state.platform === "macos",
        "pt-2": stateService.state.platform !== "macos",
      }}
    >
      <div>
        <SidebarButton notInSection target="/dashboard" icon={<FiHome />}>
          {t("sidebar.button.overview")}
        </SidebarButton>
        <For each={sidebarSections}>
          {(section) => (
            <SidebarSection title={section.title}>
              <For each={section.buttons}>
                {(button) => (
                  <SidebarButton target={button.target} icon={button.icon}>
                    {button.label}
                  </SidebarButton>
                )}
              </For>
            </SidebarSection>
          )}
        </For>
      </div>
      <div class="flex flex-col gap-4">
        <SidebarButton target="/dashboard/settings" icon={<FiSettings />} notInSection>
          {t("sidebar.button.settings")}
        </SidebarButton>
        <Hr />
        <Listbox value={selected()} onSelectChange={setSelected} defaultOpen={false}>
          <ListboxButton class="text-sm flex flex-row items-center justify-start gap-2.5 lg:gap-4 hover:bg-[#AFAEAF]/20 dark:hover:bg-neutral-100/15 bg-transparent rounded-[5px] px-2 py-[3px] w-full">
            <div class="flex h-8 w-8 items-center justify-center lg:h-10 lg:w-10 rounded-full bg-secondary opacity-50">
              <FiUsers class="w-5 h-5 text-primary" />
            </div>
            <span class="block truncate">{company.name}</span>
          </ListboxButton>
          <div class="flex flex-col w-full">
            <div class="relative">
              <DisclosureStateChild>
                {({ isOpen }): JSX.Element => (
                  <Transition
                    show={isOpen()}
                    enter="transition ease-out duration-100"
                    enterFrom="transform opacity-0 scale-95"
                    enterTo="transform opacity-100 scale-100"
                    leave="transition ease-in duration-75"
                    leaveFrom="transform opacity-100 scale-100"
                    leaveTo="transform opacity-0 scale-95"
                  >
                    <ListboxOptions
                      unmount={false}
                      class="absolute bottom-full w-full py-1 mb-1 overflow-auto text-base bg-primary rounded-md shadow-menu max-h-60 ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm"
                    >
                      <For each={companies()}>
                        {(company): JSX.Element => (
                          <ListboxOption
                            class="focus:outline-none group px-1"
                            value={company}
                            onClick={() => setCompany(company)}
                          >
                            {({ isActive, isSelected }): JSX.Element => (
                              <div
                                classList={{
                                  "text-primary bg-material-selection": isActive(),
                                  "text-opaque-1": !isActive(),
                                  "group-hover:text-primary group-hover:bg-material-selection": true,
                                  "cursor-default select-none relative py-2 pl-10 pr-4 rounded": true,
                                }}
                              >
                                <span
                                  classList={{
                                    "font-bold": isSelected(),
                                    "font-normal": !isSelected(),
                                    "block truncate": true,
                                  }}
                                >
                                  {company.name}
                                </span>
                                {isSelected() && (
                                  <span
                                    classList={{
                                      "text-primary": isActive(),
                                      "group-hover:text-primary": true,
                                      "absolute inset-y-0 left-0 flex items-center pl-3": true,
                                    }}
                                  >
                                    <FiCheck aria-hidden="true" />
                                  </span>
                                )}
                              </div>
                            )}
                          </ListboxOption>
                        )}
                      </For>
                      <ListboxOption
                        value={""}
                        class="focus:outline-none group px-1"
                        onClick={() => navigate("/setup")}
                      >
                        {({ isActive }): JSX.Element => (
                          <div
                            classList={{
                              "text-primary bg-material-selection": isActive(),
                              "text-opaque-1": !isActive(),
                              "group-hover:text-primary group-hover:bg-material-selection": true,
                              "cursor-default select-none relative py-2 pl-10 pr-4 rounded": true,
                            }}
                          >
                            <span
                              classList={{
                                "text-primary": isActive(),
                                "group-hover:text-primary": true,
                                "absolute inset-y-0 left-0 flex items-center pl-3": true,
                              }}
                            >
                              <FiPlus />
                            </span>
                            <span class="block truncate">{t("sidebar.button.company.create")}</span>
                          </div>
                        )}
                      </ListboxOption>
                    </ListboxOptions>
                  </Transition>
                )}
              </DisclosureStateChild>
            </div>
          </div>
        </Listbox>
      </div>
    </div>
  );
};

export default Sidebar;


----- src/screens/Dashboard/components/Sidebar/Section.tsx -----
import type { ParentComponent } from "solid-js";

interface ISidebarSectionProps {
  title: string;
}

const SidebarSection: ParentComponent<ISidebarSectionProps> = (props) => {
  return (
    <>
      <div class="mt-4 text-xs font-medium text-secondary">{props.title}</div>
      <div class="">{props.children}</div>
    </>
  );
};

export default SidebarSection;


----- src/screens/Dashboard/components/Sidebar/Profile/Button.tsx -----
import type { ParentComponent } from "solid-js";

interface IProfileButtonProps {
  onClick: () => void;
}

const ProfileButton: ParentComponent<IProfileButtonProps> = (props) => {
  return (
    <div
      onClick={props.onClick}
      class="inline-flex justify-center items-center w-9 h-9 rounded-md border-t transition-all transform border-zinc-700/50 bg-zinc-800 active:translate-y-1 hover:bg-zinc-700 text-red"
    >
      {props.children}
    </div>
  );
};

export default ProfileButton;


----- src/screens/Dashboard/components/Sidebar/Button.tsx -----
import { A } from "@solidjs/router";
import type { JSX, ParentComponent } from "solid-js";

const SidebarButton: ParentComponent<{
  icon?: JSX.Element;
  notInSection?: boolean;
  target: string;
}> = (props) => {
  return (
    <A
      href={props.target}
      end
      class={`mt-1 flex items-center gap-[7px] rounded-[5px] px-2 py-[3px] text-primary text-sm transition-all hover:cursor-pointer hover:bg-[#AFAEAF]/20 dark:hover:bg-neutral-100/15 ${
        !props.notInSection ? "ml-2" : ""
      }`}
      activeClass="dark:bg-neutral-100/25 bg-[#AFAEAF]/70 hover:bg-[#AFAEAF]/70 dark:hover:bg-neutral-100/25"
    >
      {props.icon}
      {props.children}
    </A>
  );
};

export default SidebarButton;


----- src/screens/Dashboard/components/Popup/Popup.tsx -----
import type { ParentComponent } from "solid-js";

const Popup: ParentComponent<{}> = (props) => {
  return <div>{props.children}</div>;
};

export default Popup;


----- src/screens/Dashboard/components/Tabs.tsx -----


----- src/screens/Dashboard/components/Container.tsx -----
import type { ParentComponent } from "solid-js";

const Container: ParentComponent<{ class?: string }> = (props) => {
  return <div class={`pt-10px px-4 w-full h-full ${props.class}`}>{props.children}</div>;
};

export default Container;


----- src/screens/Dashboard/components/StatBox.tsx -----
import { useI18n } from "@/i18n";
import { useSelector } from "@/store";
import { type Component, Show } from "solid-js";

const StatBox: Component<{
  class?: string;
  title: string;
  value: number;
  last?: number;
}> = (props) => {
  const percentageChange = (current: number, last?: number) => {
    if (!last) return 0;

    const percentage = ((current - last) / last) * 100;
    return Number(percentage.toFixed(2));
  };
  const [t] = useI18n();

  const settings = useSelector((state) => state.settingsService.settings);

  const percentage = percentageChange(props.value, props.last);
  const isNegative = percentage < 0;

  return (
    <div
      class={`p-2.5 rounded-lg border bg-element border-default h-full max-h-30 w-full relative overflow-hidden ${props.class}`}
    >
      <div
        class={"absolute top-0 right-0 w-14 h-8 rounded-lg blur-md"}
        classList={{
          "bg-red-500/30": isNegative,
          "bg-green-500/30": !isNegative,
        }}
      />
      <div class="flex flex-col justify-between items-stretch w-full h-full">
        <div class="flex flex-row justify-between items-start">
          <p class="text-xs font-medium">{props.title}</p>
          <div
            class={"text-sm"}
            classList={{
              "text-red-600": isNegative,
              "text-green-600": !isNegative,
            }}
          >
            {percentage}%
          </div>
        </div>
        <div class="flex flex-col justify-between text-secondary gap-1">
          <p class="text-xl font-medium text-primary">
            {props.value} {settings.defaultCurrency.code}
          </p>
          <Show when={props.last}>
            <p class="text-xs font-normal">
              {props.last} {settings.defaultCurrency.code} {t("statbox.lastMonth")}
            </p>
          </Show>
        </div>
      </div>
    </div>
  );
};

export default StatBox;


----- src/screens/Dashboard/components/PageHeader/index.tsx -----
import { type Component, For, Show, type JSX } from "solid-js";
import { useNavigate } from "@solidjs/router";
import { FiChevronLeft, FiChevronRight } from "solid-icons/fi";
import { useSelector } from "@/store";

interface PageHeaderProps {
  title: string[];
  actionElements?: JSX.Element[];
}

const PageHeader: Component<PageHeaderProps> = (props) => {
  const platform = useSelector((state) => state.stateService.state.platform);
  const navigate = useNavigate();

  return (
    <div
      class="flex fixed top-0 flex-row h-[40px] z-9999"
      classList={{
        "left-200px lg:left-220px w-[calc(100vw-200px)] lg:w-[calc(100vw-220px)]": platform !== "macos",
        "left-0 w-screen": platform === "macos",
        "rounded-tl-xl": platform == "windows",
      }}
    >
      <Show when={platform === "macos"}>
        <div
          class="flex items-center justify-end h-full shrink-0 px-2.5 lg:px-4 text-primary lg:w-[220px] w-[200px]"
          data-tauri-drag-region
        />
      </Show>
      <div
        class="flex justify-between items-center px-3 h-full border-b lg:px-6 lg:w-full border-black/20  backdrop-blur-lg bg-[#E3E3E3]/80 dark:bg-[#262626]/80 z-5"
        classList={{
          "w-4/5": platform === "macos",
          "w-full": platform !== "macos",
          "rounded-tl-xl": platform === "windows"
        }}
        data-tauri-drag-region
      >
        <div class="flex flex-row h-full">
          <div class="flex items-center justify-center  gap-3 text-sm font-semibold mr-5" data-tauri-drag-region>
            <button
              class="rounded hover:bg-fills-opaque-4 bg-transparent transition-all p-1 flex items-center justify-center text-primary"
              type="button"
              onClick={() => navigate(-1)}
            >
              <FiChevronLeft class="w-5 h-5 " />
            </button>

            <button
              class="rounded hover:bg-fills-opaque-4 bg-transparent transition-all p-1 flex items-center justify-center text-primary"
              type="button"
              onClick={() => navigate(1)}
            >
              <FiChevronRight class="w-5 h-5" />
            </button>
          </div>
          <div class="flex gap-1 items-center h-full text-sm font-semibold" data-tauri-drag-region>
            <For each={props.title}>
              {(item, index) => (
                <Show
                  when={index() === props.title.length - 1}
                  fallback={
                    <>
                      <span class="text-secondary" data-tauri-drag-region>
                        {item}
                      </span>
                      <span class="text-secondary" data-tauri-drag-region>
                        /
                      </span>
                    </>
                  }
                >
                  <span class="text-primary" data-tauri-drag-region>
                    {item}
                  </span>
                </Show>
              )}
            </For>
          </div>
        </div>
        <div class="flex flex-row gap-4 items-center py-1.5 h-full text-primary">
          {props.actionElements?.reverse().map((item) => item)}
        </div>
      </div>
    </div>
  );
};

export default PageHeader;


----- src/screens/Dashboard/components/PageHeader/HeaderButton.tsx -----
import type { ParentComponent } from "solid-js";

const HeaderButton: ParentComponent<{ buttonType?: "primary" | "secondary"; onClick?: (e: MouseEvent) => void }> = ({
  buttonType = "secondary",
  onClick,
  children,
}) => {
  return (
    <button
      type="button"
      classList={{
        "bg-black text-white dark:(bg-white text-black)": buttonType === "primary",
        "bg-secondary": buttonType === "secondary",
        "rounded h-full px-5 flex items-center justify-center text-sm text-primary": true,
      }}
      onClick={onClick}
    >
      {children}
    </button>
  );
};

export default HeaderButton;


----- src/screens/Dashboard/components/TemplateHint.tsx -----
import { useI18n } from "@/i18n";
import { FiChevronDown, FiChevronUp } from "solid-icons/fi";
import { type Component, createSignal, For, onMount, Show } from "solid-js";

interface Row {
  key: string;
  value: string | number | boolean | object;
  isCollapsible: boolean;
  collapsed: boolean;
}

const TemplateBuilderHint: Component<{ data?: object }> = (props) => {
  const [rows, setRows] = createSignal<Row[]>([]);
  const [t] = useI18n();

  const hints = {
    number: t("hints.number"),
    client: {
      name: t("hints.client.name"),
      cin: t("hints.client.cin"),
      vatId: t("hints.client.vatId"),
      address: t("hints.client.address"),
      city: t("hints.client.city"),
      zip: t("hints.client.zip"),
      email: t("hints.client.email"),
      phone: t("hints.client.phone"),
      bankAccount: t("hints.client.bankAccount"),
      IBAN: t("hints.client.iban"),
    },
    company: {
      name: t("hints.company.name"),
      cin: t("hints.company.cin"),
      vatId: t("hints.company.vatId"),
      address: t("hints.company.address"),
      city: t("hints.company.city"),
      zip: t("hints.company.zip"),
      email: t("hints.company.email"),
      phone: t("hints.company.phone"),
      bankAccount: t("hints.company.bankAccount"),
      IBAN: t("hints.company.iban"),
    },
    currency: {
      code: t("hints.currency.code"),
    },
    issueDate: t("hints.issueDate"),
    dueDate: t("hints.dueDate"),
    items: [
      {
        description: t("hints.items.description"),
        quantity: t("hints.items.quantity"),
        price: t("hints.items.price"),
      },
    ],
  };

  const initializeRows = () => {
    const hintData = props.data || hints;
    const hintRows = Object.entries(hintData)
      .map(([key, value]) => ({
        key,
        value,
        isCollapsible: typeof value === "object",
        collapsed: true,
      }))
      .sort((a, b) => Number(a.isCollapsible) - Number(b.isCollapsible));
    setRows(hintRows);
  };

  onMount(initializeRows);

  const getKey = (row: Row) => {
    const isArray = Array.isArray(row.value);
    if (isArray) {
      return `${row.key}[number]`;
    }
    return row.key;
  };

  const toggleCollapse = (index: number) => {
    setRows((prevRows) => {
      const updatedRows = [...prevRows];
      const row = updatedRows[index];
      updatedRows[index] = { ...row, collapsed: !row.collapsed }; // Update only the clicked row
      return updatedRows;
    });
  };

  return (
    <For each={rows()}>
      {(r, i) => (
        <>
          <div
            class={`flex gap-2 text-sm text-secondary whitespace-nowrap items-center  ${
              r.isCollapsible ? "cursor-pointer" : ""
            }`}
            onClick={() => r.isCollapsible && toggleCollapse(i())}
          >
            <div>{getKey(r)}</div>
            <Show when={!r.isCollapsible}>
              <div class="font-semibold text-primary">{String(r.value)}</div>
            </Show>
            <Show when={r.isCollapsible && Array.isArray(r.value)}>
              <div class="text-blue-600 bg-blue-100 border-default border tracking-tighter rounded text-xs px-1">
                {t("hints.collapsible.array")}
              </div>
            </Show>
            <Show when={r.isCollapsible && !Array.isArray(r.value)}>
              <div class="text-pink-600 bg-pink-100 border-default border tracking-tighter rounded text-xs px-1">
                {t("hints.collapsible.object")}
              </div>
            </Show>
            <Show when={r.isCollapsible}>
              <Show when={r.collapsed} fallback={<FiChevronUp />}>
                <FiChevronDown />
              </Show>
            </Show>
          </div>
          <Show when={!r.collapsed && r.isCollapsible}>
            <div class="border-l-1 border-default pl-3">
              <TemplateBuilderHint data={r.value as object} />
            </div>
          </Show>
        </>
      )}
    </For>
  );
};

export default TemplateBuilderHint;


----- src/screens/Dashboard/components/Table/index.tsx -----
import { createSignal, For, type JSX, Suspense, createResource } from "solid-js";
import Pagination from "./Pagination";
import TableHead from "./TableHeader";
import TableRow from "./Row";

export interface Indicies {
  skip: number;
  take: number;
}

interface TableProps<T extends Record<string, unknown>> {
  columns: Array<{ field: keyof T; header: string; component?: (item: T) => JSX.Element }>;
  loadPage: (indices: Indicies) => Promise<T[]>;
  totalItems: Promise<number>;
  allowedCounts?: number[];
  onClickRow?: (item: T) => void;
}

const Table = <T extends Record<string, unknown>>(props: TableProps<T>) => {
  const [totalItems] = createResource<number>(async () => await props.totalItems);
  const [indicies, setIndicies] = createSignal<Indicies>({ skip: 0, take: props.allowedCounts?.[0] || 10 });

  const [data] = createResource(indicies, props.loadPage);

  return (
    <div class="flex h-full flex-col justify-between">
      <table class="min-w-full leading-normal">
        <TableHead columns={props.columns} />
        <tbody class="overflow-y-auto">
          <Suspense>
            <For each={data()}>
              {(item) => <TableRow item={item} columns={props.columns} onClick={props.onClickRow} />}
            </For>
          </Suspense>
        </tbody>
      </table>
      <Suspense>
        <Pagination
          allowedCounts={props.allowedCounts}
          itemCount={totalItems() as number}
          onIndexChange={(indices) => setIndicies(indices)}
        />
      </Suspense>
    </div>
  );
};

export default Table;


----- src/screens/Dashboard/components/Table/Pagination.tsx -----
import { useI18n } from "@/i18n";
import { SegmentedControl } from "@/shared/components/SegmentedControl";
import { FiChevronLeft, FiChevronRight } from "solid-icons/fi";
import { Show, createSignal } from "solid-js";
import type { Indicies } from ".";

interface PaginationProps {
  itemCount: number;
  allowedCounts?: number[];
  onIndexChange: (indices: Indicies) => void;
}

const Pagination = (props: PaginationProps) => {
  const [pageNo, setPageNo] = createSignal(1);
  const [count, setCount] = createSignal(props.allowedCounts?.[0] || 10);
  const [t] = useI18n();

  const maxPages = () => Math.ceil(props.itemCount / count());

  const filteredCounts = () => {
    return props.allowedCounts || [10, 20, 50, -1];
  };

  const setPageNoHandler = (value: number) => {
    value = Number.parseInt(String(value));
    if (Number.isNaN(value)) {
      return;
    }

    setPageNo(Math.min(Math.max(1, value), maxPages()));
    emitIndices();
  };

  const setCountHandler = (c: number) => {
    setPageNo(1);
    if (c === -1) {
      c = props.itemCount;
    }
    setCount(c);
    emitIndices();
  };

  const emitIndices = () => {
    const indices = getSliceIndices();
    props.onIndexChange(indices);
  };

  const getSliceIndices = () => {
    const skip = (pageNo() - 1) * count();
    const take = count();
    return { skip, take };
  };

  return (
    <div class="grid grid-cols-3 text-primary text-sm select-none items-center h-12">
      {/* Length Display */}
      <div class="justify-self-start">
        {`${(pageNo() - 1) * count() + 1} - ${Math.min(pageNo() * count(), props.itemCount)}`}
      </div>

      {/* Pagination Selector */}
      <div class="flex gap-2 items-center justify-self-center">
        <FiChevronLeft
          class={`w-4 h-4 rtl-rotate-180 ${pageNo() > 1 ? "text-primary cursor-pointer" : "text-transparent"}`}
          onClick={() => setPageNoHandler(Math.max(1, pageNo() - 1))}
        />
        <div class="flex gap-2 bg-secondary rounded h-22px">
          <input
            type="number"
            class="w-8 text-end outline-none bg-transparent "
            value={pageNo()}
            min="1"
            max={maxPages()}
            onChange={(e) => setPageNoHandler(e.target.valueAsNumber)}
            onInput={(e) => setPageNoHandler(e.target.valueAsNumber)}
          />
          <p>/</p>
          <p class="w-8 flex items-center">{maxPages()}</p>
        </div>
        <FiChevronRight
          class={`w-4 h-4 rtl-rotate-180 ${pageNo() < maxPages() ? "text-primary cursor-pointer" : "text-transparent"}`}
          onClick={() => setPageNoHandler(Math.min(maxPages(), pageNo() + 1))}
        />
      </div>

      {/* Count Selector */}
      <div class="justify-self-end w-full">
        <Show when={filteredCounts().length > 1}>
          <SegmentedControl
            options={filteredCounts().map((c) => ({
              id: String(c),
              label: c === -1 ? t("table.all") : String(c),
            }))}
            onChange={(value) => setCountHandler(Number(value))}
          />
        </Show>
      </div>
    </div>
  );
};

export default Pagination;


----- src/screens/Dashboard/components/Table/TableHeader.tsx -----
import { For } from "solid-js";

interface TableHeadProps<T> {
  columns: Array<{ field: keyof T; header: string }>;
}

const TableHead = <T,>(props: TableHeadProps<T>) => {
  return (
    <thead>
      <tr class="text-left bg-[#fff] dark:bg-#353536 shadow-menu-border">
        <For each={props.columns}>
          {(column, index) => (
            <th
              class="px-3 py-1 text-primary text-sm tracking-wider rounded-r-lg"
              classList={{
                "rounded-l-lg": index() === 0,
                "rounded-r-lg": index() === props.columns.length - 1,
              }}
            >
              {column.header}
            </th>
          )}
        </For>
      </tr>
    </thead>
  );
};

export default TableHead;


----- src/screens/Dashboard/components/Table/ActionButton.tsx -----
import type { Component } from "solid-js";
import { Dynamic } from "solid-js/web";

interface ActionButtonProps {
  onClick: () => void;
  icon?: Component;
}

const ActionButton: Component<ActionButtonProps> = (props) => {
  return (
    <button type="button" class="text-default w-5 h-5 bg-red/0" onClick={props.onClick}>
      <Dynamic component={props.icon} />
    </button>
  );
};

export default ActionButton;


----- src/screens/Dashboard/components/Table/Row.tsx -----
import { For, type JSX } from "solid-js";

interface TableRowProps<T> {
  item: T;
  columns: Array<{ field: keyof T; header: string; component?: (item: T) => JSX.Element }>;
  onClick?: (item: T) => void;
}
const TableRow = <T,>(props: TableRowProps<T>) => {
  return (
    <tr
      onClick={() => props.onClick?.(props.item)}
      class="border-b border-default"
      classList={{
        "cursor-pointer transition-all hover:bg-fills-opaque-5": Boolean(props.onClick),
      }}
    >
      <For each={props.columns}>
        {(column) => <td class="px-3 py-2">{column.component?.(props.item) ?? String(props.item[column.field])}</td>}
      </For>
    </tr>
  );
};

export default TableRow;


----- src/screens/Dashboard/components/Box.tsx -----
import type { ParentComponent } from "solid-js";

const Box: ParentComponent<{ class?: string; chart?: boolean }> = (props) => {
  return (
    <div
      class={`rounded-lg border bg-element border-default h-full w-full ${props.class}`}
      classList={{
        "pb-2 pr-1": props.chart,
        "p-2.5": !props.chart,
      }}
    >
      {props.children}
    </div>
  );
};

export default Box;


----- src/screens/Dashboard/components/StatusIcon.tsx -----
import type { ParentComponent } from "solid-js";

const StatusIcon: ParentComponent = (props) => {
  return (
    <div class="flex items-center justify-center bg-default border-default rounded-md border-1 max-w-30 text-sm">
      {props.children}
    </div>
  );
};

export default StatusIcon;


----- src/screens/Dashboard/pages/index.tsx -----
import type { Component } from "solid-js";
import { Show, createResource } from "solid-js";
import Box from "../components/Box";
import { useI18n } from "@/i18n";
import PageHeader from "../components/PageHeader";
import Container from "../components/Container";
import { SolidApexCharts } from "solid-apexcharts";
import { getDocumentStats, getExpenses, getSales, DocumentType } from "@/bindings";
import StatBox from "../components/StatBox";

const Overview: Component = () => {
  const [t] = useI18n();
  const [sales] = createResource(6, getSales);
  const [expenses] = createResource(6, getExpenses);

  const [sentInvoices] = createResource(6, () => getDocumentStats(6, DocumentType.INVOICE));
  const [receivedInvoices] = createResource(6, () => getDocumentStats(6, DocumentType.RECEIVE));

  const getLastSixMonths = () => {
    const months = [];
    const currentDate = new Date();

    for (let i = 5; i >= 0; i--) {
      const month = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
      const monthName = getMonthName(month.getMonth());
      months.push(monthName);
    }

    return months.reverse();
  };

  const getMonthName = (monthIndex: number) => {
    switch (monthIndex) {
      case 0:
        return t("overview.months.january");
      case 1:
        return t("overview.months.february");
      case 2:
        return t("overview.months.march");
      case 3:
        return t("overview.months.april");
      case 4:
        return t("overview.months.may");
      case 5:
        return t("overview.months.june");
      case 6:
        return t("overview.months.july");
      case 7:
        return t("overview.months.august");
      case 8:
        return t("overview.months.september");
      case 9:
        return t("overview.months.october");
      case 10:
        return t("overview.months.november");
      case 11:
        return t("overview.months.december");
      default:
        return "";
    }
  };

  return (
    <Container>
      <PageHeader title={[t("sidebar.button.overview")]} />
      <div class="grid grid-cols-2 grid-rows-5 gap-3 w-full h-screen">
        <div class="col-span-2">
          <div class="flex flex-row gap-3 lg:gap-4 justify-between items-center w-full h-full">
            <Show when={sales() && expenses()}>
              <StatBox title={t("overview.stats.sales")} value={sales()[0]} last={sales()[1]} />
              <StatBox title={t("overview.stats.expenses")} value={expenses()[0]} last={expenses()[1]} />
            </Show>
          </div>
        </div>
        <div class="col-span-2 row-span-2 row-start-2">
          <Box chart>
            <Show when={sales() && expenses()}>
              <SolidApexCharts
                type="area"
                options={{
                  chart: {
                    type: "area",
                    toolbar: {
                      show: false,
                    },
                    width: "100%",
                    height: "100%",
                  },
                  dataLabels: {
                    enabled: false,
                  },
                  stroke: {
                    curve: "smooth",
                  },
                  xaxis: {
                    categories: getLastSixMonths(),
                    labels: {
                      style: {
                        colors: "var(--color-primary)",
                        fontSize: "12px",
                        fontWeight: 400,
                        cssClass: "apexcharts-xaxis-label",
                      },
                    },
                    axisBorder: {
                      show: true,
                      color: "var(--color-border)",
                      offsetX: 0,
                      offsetY: 0,
                    },
                    axisTicks: {
                      show: true,
                      borderType: "solid",
                      color: "var(--color-border)",
                      height: 6,
                      offsetX: 0,
                      offsetY: 0,
                    },
                  },
                  yaxis: {
                    labels: {
                      style: {
                        colors: "var(--color-primary)",
                        fontSize: "12px",
                        fontWeight: 400,
                        cssClass: "apexcharts-yaxis-label",
                      },
                    },
                  },
                  grid: {
                    show: true,
                    borderColor: "var(--color-border)",
                    strokeDashArray: 0,
                    position: "back",
                    xaxis: {
                      lines: {
                        show: true,
                      },
                    },
                    yaxis: {
                      lines: {
                        show: true,
                      },
                    },
                    row: {
                      opacity: 0.5,
                    },
                    column: {
                      opacity: 0.5,
                    },
                    padding: {
                      top: 0,
                      right: 0,
                      bottom: 0,
                      left: 20,
                    },
                  },
                  tooltip: {
                    theme: "dark",
                    style: {
                      fontSize: "12px",
                    },
                  },
                  legend: {
                    labels: {
                      colors: "var(--color-primary)",
                      useSeriesColors: false,
                    },
                  },
                }}
                series={[
                  {
                    name: t("overview.chart.sales"),
                    data: sales() as number[],
                  },
                  {
                    name: t("overview.chart.expenses"),
                    data: expenses() as number[],
                  },
                ]}
              />
            </Show>
          </Box>
        </div>
        <div class="col-span-2 row-start-4 row-span-2">
          <Box chart>
            <Show when={sentInvoices() && receivedInvoices()}>
              <SolidApexCharts
                type="bar"
                options={{
                  chart: {
                    type: "bar",
                    toolbar: {
                      show: false,
                    },
                    width: "100%",
                    height: "100%",
                  },
                  plotOptions: {
                    bar: {
                      horizontal: false,
                      columnWidth: "55%",
                    },
                  },
                  dataLabels: {
                    enabled: false,
                  },
                  stroke: {
                    show: true,
                    width: 2,
                    colors: ["transparent"],
                  },
                  xaxis: {
                    categories: getLastSixMonths(),
                    labels: {
                      style: {
                        colors: "var(--color-primary)",
                        fontSize: "12px",
                        fontWeight: 400,
                        cssClass: "apexcharts-xaxis-label",
                      },
                    },
                    axisBorder: {
                      show: true,
                      color: "var(--color-border)",
                      offsetX: 0,
                      offsetY: 0,
                    },
                    axisTicks: {
                      show: true,
                      borderType: "solid",
                      color: "var(--color-border)",
                      height: 6,
                      offsetX: 0,
                      offsetY: 0,
                    },
                  },
                  yaxis: {
                    labels: {
                      style: {
                        colors: "var(--color-primary)",
                        fontSize: "12px",
                        fontWeight: 400,
                        cssClass: "apexcharts-yaxis-label",
                      },
                      formatter: (value: number) => {
                        if (value % 1 === 0) {
                          return value.toString();
                        }
                        return "";
                      },
                    },
                  },
                  grid: {
                    show: true,
                    borderColor: "var(--color-border)",
                    strokeDashArray: 0,
                    position: "back",
                    xaxis: {
                      lines: {
                        show: true,
                      },
                    },
                    yaxis: {
                      lines: {
                        show: true,
                      },
                    },
                    row: {
                      opacity: 0.5,
                    },
                    column: {
                      opacity: 0.5,
                    },
                    padding: {
                      top: 0,
                      right: 0,
                      bottom: 0,
                      left: 20,
                    },
                  },
                  tooltip: {
                    theme: "dark",
                    style: {
                      fontSize: "12px",
                    },
                  },
                  legend: {
                    labels: {
                      colors: "var(--color-primary)",
                      useSeriesColors: false,
                    },
                  },
                }}
                series={[
                  {
                    name: t("overview.chart.sentInvoices"),
                    data: sentInvoices() as number[],
                  },
                  {
                    name: t("overview.chart.receivedInvoices"),
                    data: receivedInvoices() as number[],
                  },
                ]}
              />
            </Show>
          </Box>
        </div>
      </div>
    </Container>
  );
};

export default Overview;


----- src/screens/Dashboard/pages/Settings/index.tsx -----
import { type Component, createSignal, createResource, Show } from "solid-js";
import Toolbar from "./components/Toolbar";
import { FiFileText, FiFlag, FiSettings } from "solid-icons/fi";
import { locale, setLocale, useI18n } from "@/i18n";
import Input from "@/shared/components/Form/Input";
import PageHeader from "../../components/PageHeader";
import Form from "@/shared/components/Form";
import { createForm } from "@tanstack/solid-form";
import {
  type ManageSettingsData,
  getCurrencies,
  getTemplates,
  updateSettings,
  type ManageCompanyData,
  updateCompany,
} from "@/bindings";
import { useSelector } from "@/store";
import toast from "solid-toast";
import SearchDropdown from "@/shared/components/Form/SearchDropdown";
import Button from "@/shared/components/Button";
import Container from "../../components/Container";
import Section from "@/shared/components/Form/Section";
import LanguageBox from "@/screens/Setup/components/LanguageBox";
import { LANG } from "@/constants";

const Settings: Component = () => {
  const [t] = useI18n();
  const [currentSection, setCurrentSection] = createSignal(0);

  return (
    <Container>
      <PageHeader title={[t("sidebar.button.settings")]} />
      <div class="w-full h-20 gap-2 flex justify-center items-center border-b border-black/20">
        <Toolbar
          text={t("settings.general.title")}
          icon={<FiSettings />}
          active={currentSection() === 0}
          onClick={() => setCurrentSection(0)}
        />
        <Toolbar
          text={t("settings.document.title")}
          icon={<FiFileText />}
          active={currentSection() === 1}
          onClick={() => setCurrentSection(1)}
        />
        <Toolbar
          text={t("settings.language")}
          icon={<FiFlag />}
          active={currentSection() === 2}
          onClick={() => setCurrentSection(2)}
        />
      </div>
      <div class="w-full h-full">
        <Show when={currentSection() === 0}>
          <CompanyPage />
        </Show>
        <Show when={currentSection() === 1}>
          <DocumentPage />
        </Show>
        <Show when={currentSection() === 2}>
          <div class="flex gap-4 justify-center items-center mt-20">
            <LanguageBox onClick={() => setLocale(LANG.CS)} active={locale() === LANG.CS}>
              🇨🇿
            </LanguageBox>
            <LanguageBox onClick={() => setLocale(LANG.EN)} active={locale() === LANG.EN}>
              🇬🇧
            </LanguageBox>
          </div>
        </Show>
      </div>
    </Container>
  );
};

export default Settings;

const DocumentPage: Component = () => {
  const [templates] = createResource(async () => await getTemplates({ skip: 0, take: 1000 }));
  const [currencies] = createResource({ skip: 0, take: 1000 }, getCurrencies);
  const [t] = useI18n();

  const settingsService = useSelector((state) => state.settingsService);

  const form = createForm(() => ({
    defaultValues: {
      id: settingsService.settings.id,
      defaultCurrencyId: settingsService.settings.defaultCurrency.id,
      defaultTemplateId: settingsService.settings.defaultTemplate.id,

      invoicePrefix: settingsService.settings.invoicePrefix,
      receivePrefix: settingsService.settings.receivePrefix,
      proformaPrefix: settingsService.settings.proformaPrefix,

      invoiceCounter: settingsService.settings.invoiceCounter,
      receiveCounter: settingsService.settings.receiveCounter,
      proformaCounter: settingsService.settings.proformaCounter,
    } as ManageSettingsData,
    onSubmit: async (data) => {
      try {
        await updateSettings(data.value);
        await settingsService.updateSettings();
        toast.success(t("settings.document.toast.saved"));
      } catch (e) {
        console.error(e);
        toast.error(t("settings.document.toast.saveFailed"));
      }
    },
  }));

  return (
    <Form>
      <Section title={t("settings.document.sections.defaults")}>
        <form.Field name="defaultTemplateId">
          {(field) => (
            <Show when={templates()}>
              <SearchDropdown
                data={templates()?.map((template) => ({ id: template.id, label: template.name })) ?? []}
                defaultValueId={field().state.value}
                label={t("settings.document.template")}
                onSelect={(data) => field().handleChange(data.id as number)}
              />
            </Show>
          )}
        </form.Field>

        <form.Field name="defaultCurrencyId">
          {(field) => (
            <Show when={currencies()}>
              <SearchDropdown
                data={currencies()?.map((currency) => ({ id: currency.id, label: currency.name })) ?? []}
                defaultValueId={field().state.value}
                label={t("settings.document.currency")}
                onSelect={(data) => field().handleChange(data.id as string)}
              />
            </Show>
          )}
        </form.Field>
      </Section>
      <Section title={t("settings.document.sections.prefixesCounters")}>
        <form.Field name="invoicePrefix">
          {(field) => (
            <Input
              type="text"
              label={t("settings.document.invoicePrefix")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="invoiceCounter">
          {(field) => (
            <Input
              type="number"
              label={t("settings.document.invoiceCounter")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="proformaPrefix">
          {(field) => (
            <Input
              type="text"
              label={t("settings.document.proformaPrefix")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="proformaCounter">
          {(field) => (
            <Input
              type="number"
              label={t("settings.document.proformaCounter")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="receivePrefix">
          {(field) => (
            <Input
              type="text"
              label={t("settings.document.receivePrefix")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="receiveCounter">
          {(field) => (
            <Input
              type="number"
              label={t("settings.document.receiveCounter")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
      </Section>
      <Button onClick={() => form.handleSubmit()}>{t("settings.document.save")}</Button>
    </Form>
  );
};

const CompanyPage: Component = () => {
  const [t] = useI18n();

  const companyService = useSelector((state) => state.companyService);

  const form = createForm(() => ({
    defaultValues: {
      name: companyService.company.name,
      cin: companyService.company.cin,
      vatId: companyService.company.vatId,
      address: companyService.company.address,
      city: companyService.company.city,
      zip: companyService.company.zip,
      phone: companyService.company.phone,
      email: companyService.company.email,
      bankAccount: companyService.company.bankAccount,
      bankIban: companyService.company.bankIban,
    } as ManageCompanyData,
    onSubmit: async (data) => {
      try {
        await updateCompany(data.value);
        await companyService.updateCompany();
        toast.success(t("settings.general.toast.updated"));
      } catch (e) {
        console.error(e);
        toast.error(t("settings.general.toast.updateFailed"));
      }
    },
  }));

  return (
    <Form>
      <Section title={t("settings.general.sections.details")}>
        <form.Field name="name">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.company_name")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="cin">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.CIN")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="vatId">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.vatID")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
      </Section>
      <Section title={t("settings.general.sections.contact")}>
        <form.Field name="address">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.street")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="city">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.city")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="zip">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.zip")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="phone">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.phone")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="email">
          {(field) => (
            <Input
              type="email"
              label={t("settings.general.email")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
      </Section>
      <Section title={t("settings.general.sections.bank")}>
        <form.Field name="bankAccount">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.account")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
        <form.Field name="bankIban">
          {(field) => (
            <Input
              type="text"
              label={t("settings.general.iban")}
              defaultValue={field().state.value}
              onChange={(data) => field().handleChange(data)}
            />
          )}
        </form.Field>
      </Section>
      <Button onClick={() => form.handleSubmit()}>{t("other.save")}</Button>
    </Form>
  );
};


----- src/screens/Dashboard/pages/Settings/components/Toolbar.tsx -----
import { Component, JSX } from "solid-js";

const Toolbar: Component<{
  text: string;
  icon?: JSX.Element;
  active?: boolean;
  onClick?: () => void;
}> = (props) => {
  return (
    <div
      class="p-2 hover:bg-gray-100/5 rounded-lg flex flex-col gap-1 items-center font-medium transition cursor-pointer text-sm"
      classList={{ "bg-gray-100/5": props.active }}
      onClick={props.onClick}
    >
      {props.icon}
      {props.text}
    </div>
  );
};

export default Toolbar;


----- src/screens/Dashboard/pages/Sales/Invoices/index.tsx -----
import { DocumentType, getDocuments, getModelCount } from "@/bindings";
import { useI18n } from "@/i18n";
import Table from "@/screens/Dashboard/components/Table";
import { FiPlus } from "solid-icons/fi";
import type { Component } from "solid-js";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import Container from "@/screens/Dashboard/components/Container";
import { useNavigate } from "@solidjs/router";

const Invoices: Component = () => {
  const [t] = useI18n();
  const navigate = useNavigate();

  return (
    <Container>
      <PageHeader
        title={[t("sidebar.section.sales"), t("sidebar.button.invoices")]}
        actionElements={[
          <HeaderButton onClick={() => navigate("new")} buttonType="primary">
            <FiPlus class="stroke-2" />
          </HeaderButton>,
        ]}
      />
      <Table
        columns={[
          { field: "number", header: "Number" },
          {
            field: "totalPrice",
            header: "Total Price",
            component: (item) => (
              <>
                {item.totalPrice} {item.currency}
              </>
            ),
          },
        ]}
        totalItems={getModelCount("Invoice")}
        loadPage={async (indices) => await getDocuments(indices, DocumentType.INVOICE)}
        onClickRow={(item) => navigate(`${item.id}`)}
      />
    </Container>
  );
};

export default Invoices;


----- src/screens/Dashboard/pages/Sales/Invoices/ManageInvoice.tsx -----
import { useParams } from "@solidjs/router";
import type { Component } from "solid-js";
import ManageDocument from "../ManageDocument";
import { DocumentType } from "@/bindings";

const ManageInvoice: Component = () => {
  const params = useParams<{ readonly id?: string }>();

  return <ManageDocument type={DocumentType.INVOICE} id={params.id} url="/dashboard/sales/invoices" />;
};

export default ManageInvoice;


----- src/screens/Dashboard/pages/Sales/ReceivedInvoices/index.tsx -----
import { DocumentType, getDocuments, getModelCount } from "@/bindings";
import { useI18n } from "@/i18n";
import Table from "@/screens/Dashboard/components/Table";
import { FiPlus } from "solid-icons/fi";
import type { Component } from "solid-js";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import Container from "@/screens/Dashboard/components/Container";
import { useNavigate } from "@solidjs/router";
import { useSelector } from "@/store";

const ReceivedInvoices: Component = () => {
  const [t] = useI18n();
  const navigate = useNavigate();

  const settings = useSelector((state) => state.settingsService.settings);
  return (
    <Container>
      <PageHeader
        title={[t("sidebar.section.sales"), t("sidebar.button.receivedInvoices")]}
        actionElements={[
          <HeaderButton onClick={() => navigate("new")} buttonType="primary">
            <FiPlus class="stroke-2" />
          </HeaderButton>,
        ]}
      />
      <Table
        columns={[
          { field: "number", header: "Number" },
          {
            field: "totalPrice",
            header: "Total Price",
            component: (item) => (
              <>
                {item.totalPrice} {settings.defaultCurrency.code}
              </>
            ),
          },
        ]}
        totalItems={getModelCount("Receive")}
        loadPage={async (indices) => await getDocuments(indices, DocumentType.RECEIVE)}
        onClickRow={(item) => navigate(`${item.id}`)}
      />
    </Container>
  );
};

export default ReceivedInvoices;


----- src/screens/Dashboard/pages/Sales/ReceivedInvoices/ManageReceived.tsx -----
import { useParams } from "@solidjs/router";
import type { Component } from "solid-js";
import ManageDocument from "../ManageDocument";
import { DocumentType } from "@/bindings";

const ManageReceived: Component = () => {
  const params = useParams<{ readonly id?: string }>();

  return <ManageDocument type={DocumentType.RECEIVE} id={params.id} url="/dashboard/sales/received" />;
};

export default ManageReceived;


----- src/screens/Dashboard/pages/Sales/ManageDocument.tsx -----
import { useI18n } from "@/i18n";
import Container from "@/screens/Dashboard/components/Container";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import { useNavigate } from "@solidjs/router";
import { Index, Show, createResource, onMount, type Component } from "solid-js";
import { createForm } from "@tanstack/solid-form";
import Input from "@/shared/components/Form/Input";
import Dropdown from "@/shared/components/Form/Dropdown";
import {
  type ManageDocumentData,
  createDocument,
  deleteDocument,
  getClients,
  getCurrencies,
  getDocument,
  getTemplates,
  updateDocument,
  DocumentType,
} from "@/bindings";
import Form from "@/shared/components/Form";
import Section from "@/shared/components/Form/Section";
import toast from "solid-toast";
import { FiDownload, FiTrash, FiX } from "solid-icons/fi";
import SearchDropdown from "@/shared/components/Form/SearchDropdown";
import Button from "@/shared/components/Button";
import { useSelector } from "@/store";
import { generateDocumentNumber } from "@/utils/handleDocumentNumber";
import { getInitializedPrintWindow } from "@/utils/savePDF";
import { zodValidator } from "@tanstack/zod-form-adapter";
import { z } from "zod";

interface ManageDocumentProps {
  id?: string;
  type: DocumentType;
  url: string;
}

const ManageDocument: Component<ManageDocumentProps> = (props) => {
  const [t] = useI18n();
  const navigate = useNavigate();
  const settingsService = useSelector((state) => state.settingsService);

  const [templates] = createResource(async () => await getTemplates({ skip: 0, take: 1000 }, props.type));
  const [clients] = createResource({ skip: 0, take: 1000 }, getClients);
  const [currencies] = createResource({ skip: 0, take: 1000 }, getCurrencies);

  const form = createForm(() => ({
    defaultValues: {
      id: 0,
      number: generateDocumentNumber(
        props.type === DocumentType.INVOICE
          ? settingsService.settings.invoicePrefix
          : props.type === DocumentType.PROFORMA
            ? settingsService.settings.proformaPrefix
            : settingsService.settings.receivePrefix,
        props.type === DocumentType.INVOICE
          ? settingsService.settings.invoiceCounter + 1
          : props.type === DocumentType.RECEIVE
            ? settingsService.settings.proformaCounter + 1
            : settingsService.settings.receiveCounter + 1,
      ),
      clientId: undefined as number | undefined,
      templateId: settingsService.settings.defaultTemplate.id,
      documentType: props.type,
      currencyId: settingsService.settings.defaultCurrency.id,
      issueDate: new Date(),
      dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),
      status: "DRAFT",
      items: [],
    } as ManageDocumentData,
    validatorAdapter: zodValidator,
    onSubmit: async (document) => {
      console.log(document.value);
      try {
        if (props.id) {
          await updateDocument({
            ...document.value,
            id: Number.parseInt(props.id),
          });
          toast.success(t("pages.sales.document.toast.updated"));
        } else {
          await createDocument(document.value);
          toast.success(t("pages.sales.document.toast.saved"));
          await settingsService.updateSettings();
        }
        navigate(props.url);
      } catch (e) {
        toast.error(t("pages.sales.document.toast.saveFailed"));
        console.error(e);
      }
    },
  }));

  onMount(async () => {
    if (props.id) {
      const document = await getDocument(Number.parseInt(props.id));
      console.log(document);
      form.update({
        ...form.options,
        defaultValues: {
          ...document,
          documentType: props.type,
          dueDate: new Date(document.dueDate),
          issueDate: new Date(document.issueDate),
        },
      });
    }
  });

  return (
    <Container>
      <PageHeader
        title={[
          t("sidebar.section.sales"),
          props.type === DocumentType.INVOICE
            ? t("pages.sales.document.title.invoice")
            : props.type === DocumentType.PROFORMA
              ? t("pages.sales.document.title.proforma")
              : t("pages.sales.document.title.receive"),
          props.id ? props.id : t("pageHeader.new"),
        ]}
        actionElements={[
          <HeaderButton onClick={() => form.handleSubmit()} buttonType="primary">
            {t("other.save")}
          </HeaderButton>,
          <Show when={props.id}>
            <HeaderButton
              onClick={async () => {
                try {
                  await deleteDocument(Number.parseInt(props.id as string));
                  toast.success(t("pages.sales.document.toast.deleted"));
                  navigate(props.url);
                } catch (e) {
                  toast.error(e as string);
                }
              }}
              buttonType="secondary"
            >
              <FiTrash />
            </HeaderButton>
          </Show>,
          <Show when={props.id}>
            <HeaderButton
              onClick={async () => {
                getInitializedPrintWindow(props.id as unknown as number);
              }}
              buttonType="secondary"
            >
              <FiDownload />
            </HeaderButton>
          </Show>,
        ]}
      />
      <Form>
        <Section title={t("pages.sales.document.information")}>
          <form.Field
            name="number"
            validators={{ onChange: z.string().min(1, t("pages.sales.document.numberRequired")) }}
          >
            {(field) => (
              <Input
                type="text"
                label={t("pages.sales.document.number")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field
            name="clientId"
            validators={{ onChange: z.number().min(1, t("pages.sales.document.clientRequired")) }}
          >
            {(field) => (
              <Show when={clients()}>
                <SearchDropdown
                  data={clients()?.map((client) => ({ id: client.id, label: client.name })) ?? []}
                  label={t("pages.sales.document.client")}
                  defaultValueId={field().state.value}
                  onSelect={(data) => field().handleChange(data.id as number)}
                  errors={field().state.meta.touchedErrors}
                />
              </Show>
            )}
          </form.Field>
          <form.Field
            name="templateId"
            validators={{ onChange: z.number().min(1, t("pages.sales.document.templateRequired")) }}
          >
            {(field) => (
              <Show when={templates()}>
                <SearchDropdown
                  data={templates()?.map((template) => ({ id: template.id, label: template.name })) ?? []}
                  defaultValueId={field().state.value}
                  label={t("pages.sales.document.template")}
                  onSelect={(data) => field().handleChange(data.id as number)}
                />
              </Show>
            )}
          </form.Field>

          <form.Field
            name="currencyId"
            validators={{ onChange: z.string().min(1, t("pages.sales.document.currencyRequired")) }}
          >
            {(field) => (
              <Show when={currencies()}>
                <SearchDropdown
                  data={currencies()?.map((currency) => ({ id: currency.id, label: currency.name })) ?? []}
                  defaultValueId={field().state.value}
                  label={t("pages.sales.document.currency")}
                  onSelect={(data) => field().handleChange(data.id as string)}
                />
              </Show>
            )}
          </form.Field>

          <form.Field name="status">
            {(field) => (
              <Dropdown
                defaultValueId={field().state.value}
                label={t("pages.sales.document.status.label")}
                data={[
                  { id: "DRAFT", label: t("pages.sales.document.status.draft") },
                  { id: "SENT", label: t("pages.sales.document.status.sent") },
                  { id: "PAID", label: t("pages.sales.document.status.paid") },
                  { id: "CANCELLED", label: t("pages.sales.document.status.cancelled") },
                  { id: "OVERDUE", label: t("pages.sales.document.status.overdue") },
                ]}
                onSelect={(data) =>
                  field().handleChange(data.id as "DRAFT" | "SENT" | "PAID" | "CANCELLED" | "OVERDUE")
                }
              />
            )}
          </form.Field>
        </Section>
        <Section title={t("pages.sales.document.dates")}>
          <form.Field name="issueDate" validators={{ onChange: z.date() }}>
            {(field) => (
              <Input
                type="date"
                label={t("pages.sales.document.issueDate")}
                defaultValue={field().state.value.toISOString().split("T")[0]}
                onChange={(data) => field().handleChange(new Date(data))}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field
            name="dueDate"
            validators={{ onChange: z.date().min(new Date(), t("pages.sales.document.dueDateError")) }}
          >
            {(field) => (
              <Input
                type="date"
                label={t("pages.sales.document.dueDate")}
                defaultValue={field().state.value.toISOString().split("T")[0]}
                onChange={(data) => field().handleChange(new Date(data))}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
        </Section>
        <Section title={t("pages.sales.document.items")} columns={1}>
          <form.Field name="items">
            {(field) => (
              <>
                <Index each={field().state.value}>
                  {(_item, i) => (
                    <div class="flex gap-4 items-end">
                      <form.Field name={`items[${i}].description`} validators={{ onChange: z.string().min(1) }}>
                        {(subField) => (
                          <Input
                            type="text"
                            class="w-full"
                            label={t("pages.sales.document.itemDescription", { number: i + 1 })}
                            defaultValue={subField().state.value}
                            errors={subField().state.meta.touchedErrors}
                            onChange={(data) => subField().handleChange(data)}
                          />
                        )}
                      </form.Field>
                      <form.Field name={`items[${i}].quantity`} validators={{ onChange: z.number().min(1) }}>
                        {(subField) => (
                          <Input
                            type="number"
                            label={t("pages.sales.document.itemQuantity", { number: i + 1 })}
                            defaultValue={subField().state.value}
                            errors={subField().state.meta.touchedErrors}
                            onChange={(data) => subField().handleChange(Number(data))}
                          />
                        )}
                      </form.Field>
                      <form.Field name={`items[${i}].price`} validators={{ onChange: z.number().min(0) }}>
                        {(subField) => (
                          <Input
                            type="number"
                            label={t("pages.sales.document.itemPrice", { number: i + 1 })}
                            defaultValue={subField().state.value}
                            onChange={(data) => subField().handleChange(Number(data))}
                            errors={subField().state.meta.touchedErrors}
                          />
                        )}
                      </form.Field>

                      <FiX onClick={() => field().removeValue(i)} class="text-danger w-5 h-5 cursor-pointer mb-2" />
                    </div>
                  )}
                </Index>

                <Button
                  onClick={() => field().pushValue({ id: 0, description: "", quantity: 1, price: 0, documentId: 0 })}
                >
                  {t("pages.sales.document.addItem")}
                </Button>
              </>
            )}
          </form.Field>
        </Section>
      </Form>
    </Container>
  );
};

export default ManageDocument;


----- src/screens/Dashboard/pages/Sales/Proformas/index.tsx -----
import { DocumentType, getDocuments, getModelCount } from "@/bindings";
import { useI18n } from "@/i18n";
import Table from "@/screens/Dashboard/components/Table";
import { FiPlus } from "solid-icons/fi";
import type { Component } from "solid-js";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import Container from "@/screens/Dashboard/components/Container";
import { useNavigate } from "@solidjs/router";

const Invoices: Component = () => {
  const [t] = useI18n();
  const navigate = useNavigate();

  return (
    <Container>
      <PageHeader
        title={[t("sidebar.section.sales"), t("sidebar.button.invoices")]}
        actionElements={[
          <HeaderButton onClick={() => navigate("new")} buttonType="primary">
            <FiPlus class="stroke-2" />
          </HeaderButton>,
        ]}
      />
      <Table
        columns={[
          { field: "number", header: "Number" },
          {
            field: "totalPrice",
            header: "Total Price",
            component: (item) => (
              <>
                {item.totalPrice} {item.currency}
              </>
            ),
          },
        ]}
        totalItems={getModelCount("Proforma")}
        loadPage={async (indices) => await getDocuments(indices, DocumentType.PROFORMA)}
        onClickRow={(item) => navigate(`${item.id}`)}
      />
    </Container>
  );
};

export default Invoices;


----- src/screens/Dashboard/pages/Sales/Proformas/ManageProforma.tsx -----
import { useParams } from "@solidjs/router";
import type { Component } from "solid-js";
import ManageDocument from "../ManageDocument";
import { DocumentType } from "@/bindings";

const ManageReceived: Component = () => {
  const params = useParams<{ readonly id?: string }>();

  return <ManageDocument type={DocumentType.PROFORMA} id={params.id} url="/dashboard/sales/proformas" />;
};

export default ManageReceived;


----- src/screens/Dashboard/pages/Other/Clients/index.tsx -----
import { getClients, getModelCount } from "@/bindings";
import { useI18n } from "@/i18n";
import Table from "@/screens/Dashboard/components/Table";
import { FiPlus } from "solid-icons/fi";
import type { Component } from "solid-js";
import { useNavigate } from "@solidjs/router";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import Container from "@/screens/Dashboard/components/Container";

const Clients: Component = () => {
  const [t] = useI18n();
  const navigate = useNavigate();

  return (
    <Container>
      <PageHeader
        title={[t("sidebar.section.other"), t("sidebar.button.clients")]}
        actionElements={[
          <HeaderButton onClick={() => navigate("new")} buttonType="primary">
            <FiPlus class="stroke-2" />
          </HeaderButton>,
        ]}
      />
      <Table
        columns={[
          { field: "id", header: "ID" },
          { field: "name", header: "Name" },
          { field: "email", header: "Email" },
          { field: "phone", header: "Phone" },
        ]}
        totalItems={getModelCount("Client")}
        loadPage={getClients}
        onClickRow={(item) => navigate(`detail/${item.id}`)}
      />
    </Container>
  );
};

export default Clients;


----- src/screens/Dashboard/pages/Other/Clients/ManageClient.tsx -----
import { useI18n } from "@/i18n";
import Container from "@/screens/Dashboard/components/Container";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import { useNavigate, useParams } from "@solidjs/router";
import { Show, onMount, type Component } from "solid-js";
import { createForm } from "@tanstack/solid-form";
import Input from "@/shared/components/Form/Input";
import Dropdown from "@/shared/components/Form/Dropdown";
import { type Client, createClient, deleteClient, getClient, updateClient } from "@/bindings";
import Form from "@/shared/components/Form";
import { zodValidator } from "@tanstack/zod-form-adapter";
import { z } from "zod";
import Section from "@/shared/components/Form/Section";
import toast from "solid-toast";
import { FiTrash } from "solid-icons/fi";

const ManageClient: Component = () => {
  const params = useParams<{ readonly id?: string }>();
  const [t] = useI18n();
  const navigate = useNavigate();
  const form = createForm(() => ({
    defaultValues: {
      id: 0,
      name: "",
      clientType: "BOTH",
      cin: "",
      vatId: undefined,
      address: "",
      city: "",
      zip: "",
      phone: undefined,
      email: undefined,
      bankAccount: undefined,
      bankIban: undefined,
    } as Client,
    validatorAdapter: zodValidator,
    onSubmitInvalid: (e) => {
      console.log("invalid", e.formApi.state.errors);
    },
    onSubmit: async (client) => {
      console.log(client.value);
      try {
        if (client.value.id > 0) {
          await updateClient(client.value);
          toast.success(t("pages.other.clients.form.toast.updated"));
        } else {
          await createClient(client.value);
          toast.success(t("pages.other.clients.form.toast.saved"));
        }
        navigate("/dashboard/other/clients");
      } catch (e) {
        toast.error(t("pages.other.clients.form.toast.saveFailed"));
        console.error(e);
      }
    },
  }));

  onMount(async () => {
    if (params.id) {
      const client = await getClient(Number.parseInt(params.id));
      form.update({ ...form.options, defaultValues: client });
      console.log(form.state.values);
    }
  });

  return (
    <Container>
      <PageHeader
        title={[t("sidebar.section.sales"), t("sidebar.button.clients"), params.id ? params.id : t("pageHeader.new")]}
        actionElements={[
          <HeaderButton onClick={() => form.handleSubmit()} buttonType="primary">
            {t("pages.other.clients.form.save")}
          </HeaderButton>,
          <Show when={params.id}>
            <HeaderButton
              onClick={async () => {
                try {
                  await deleteClient(Number.parseInt(params.id as string));
                  toast.success(t("pages.other.clients.form.toast.deleted"));
                  navigate("/dashboard/other/clients");
                } catch (e) {
                  toast.error(e as string);
                }
              }}
              buttonType="secondary"
            >
              <FiTrash />
            </HeaderButton>
          </Show>,
        ]}
      />
      <Form>
        <Section title={t("pages.other.clients.form.sections.information")}>
          <form.Field name="name" validators={{ onChange: z.string().min(2).max(100), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.name")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field
            name="email"
            validators={{
              onChange: z.string().email().optional(),
              onChangeAsyncDebounceMs: 500,
            }}
          >
            {(field) => (
              <Input
                type="email"
                label={t("pages.other.clients.form.email")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="clientType">
            {(field) => (
              <Dropdown
                defaultValueId={field().state.value}
                label={t("pages.other.clients.form.clientType")}
                data={[
                  { id: "BOTH", label: t("pages.other.clients.form.clientTypes.both") },
                  { id: "SUPPLIER", label: t("pages.other.clients.form.clientTypes.supplier") },
                  { id: "CUSTOMER", label: t("pages.other.clients.form.clientTypes.customer") },
                ]}
                onSelect={(data) => field().handleChange(data.id as "BOTH" | "SUPPLIER" | "CUSTOMER")}
              />
            )}
          </form.Field>
          <form.Field name="cin" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.cin")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="vatId" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.vatId")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
        </Section>
        <Section title={t("pages.other.clients.form.sections.address")}>
          <form.Field name="address" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.address")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="city" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.city")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="zip" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.zip")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="phone" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="tel"
                label={t("pages.other.clients.form.phone")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
        </Section>
        <Section title={t("pages.other.clients.form.sections.bank")}>
          <form.Field name="bankAccount" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.bankAccount")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="bankIban" validators={{ onChange: z.string().optional(), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.clients.form.bankIban")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
        </Section>
      </Form>
    </Container>
  );
};

export default ManageClient;


----- src/screens/Dashboard/pages/Other/Clients/ClientDetail.tsx -----
import { getClient, getDocumentCount, getDocuments } from "@/bindings";
import { useI18n } from "@/i18n";
import Box from "@/screens/Dashboard/components/Box";
import Container from "@/screens/Dashboard/components/Container";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import StatBox from "@/screens/Dashboard/components/StatBox";
import Table from "@/screens/Dashboard/components/Table";
import LoadingIcon from "@/shared/components/LoadingIcon";
import { Hr } from "@/shared/components/Menu/Hr";
import { useNavigate, useParams } from "@solidjs/router";
import { FiUsers } from "solid-icons/fi";
import { type ParentComponent, Show, Suspense, createResource, type Component, type JSX } from "solid-js";

const ClientDetail: Component = () => {
  const params = useParams<{ readonly id: string }>();
  const navigate = useNavigate();
  const [t] = useI18n();

  const [client] = createResource(Number(params.id), getClient);

  return (
    <Container class="pb-3">
      <PageHeader
        title={[t("sidebar.section.sales"), t("sidebar.button.clients"), params.id]}
        actionElements={[
          <HeaderButton onClick={() => navigate(`/dashboard/other/clients/${params.id}`)} buttonType="primary">
            Edit
          </HeaderButton>,
        ]}
      />
      <div class="grid grid-cols-6 gap-3 lg:gap-4 h-full grid-rows-5">
        <StatBox class="col-span-3" title={t("overview.stats.sales")} value={100} />
        <StatBox class="col-span-3" title={t("overview.stats.expenses")} value={1654.43} last={6804.52} />
        <div class="col-span-4 row-span-4">
          <Table
            columns={[
              { field: "number", header: "Number" },
              {
                field: "totalPrice",
                header: "Total Price",
                component: (item) => (
                  <>
                    {item.totalPrice} {item.currency}
                  </>
                ),
              },
            ]}
            totalItems={getDocumentCount(undefined, Number.parseInt(params.id))}
            allowedCounts={[10]}
            loadPage={async (indices) => await getDocuments(indices, undefined, Number.parseInt(params.id))}
            onClickRow={(item) => {
              switch (item.documentType) {
                case "INVOICE":
                  navigate(`/dashboard/sales/invoices/${item.id}`);
                  break;
                case "PROFORMA":
                  navigate(`/dashboard/sales/estimates/${item.id}`);
                  break;
                case "RECEIVE":
                  navigate(`/dashboard/finance/received/${item.id}`);
                  break;
              }
            }}
          />
        </div>
        <Box class="col-span-2 row-span-4 relative overflow-scroll">
          <Suspense fallback={<LoadingIcon />}>
            <Show when={client()}>
              <div class="flex items-center flex-row gap-2 mb-2 ">
                <div class="flex h-10 w-10 items-center justify-center lg:h-10 lg:w-10 rounded-full bg-secondary opacity-50">
                  <FiUsers class="w-5 h-5 text-primary" />
                </div>
                <div class="flex flex-col ">
                  <div class="font-semibold">{client()?.name}</div>
                  <div class="text-sm ">{client()?.clientType}</div>
                </div>
              </div>
              <Hr class="my-3" />
              <div class="flex flex-col gap-1">
                <h2 class="text-primary text-sm font-semibold pb-2">Detail</h2>
                <Item title="CIN">{client()?.cin}</Item>
                <Item title="VAT">{client()?.vatId}</Item>
                <Item title="Email">{client()?.email}</Item>
                <Item title="Phone">{client()?.phone}</Item>

                <Hr class="my-2" />
                <h2 class="text-primary text-sm font-semibold pb-2">Address</h2>
                <Item title="Street">{client()?.address}</Item>
                <Item title="City">{client()?.city}</Item>
                <Item title="ZIP">{client()?.zip}</Item>

                <Hr class="my-2" />
                <h2 class="text-primary text-sm font-semibold pb-2">Bank</h2>
                <Item title="Account">{client()?.bankAccount}</Item>
                <Item title="IBAN">{client()?.bankIban}</Item>
              </div>
            </Show>
          </Suspense>
        </Box>
      </div>
    </Container>
  );
};

const Item: ParentComponent<{
  title: string;
  icon?: JSX.Element;
}> = (props) => {
  return (
    <div class="flex gap-2 items-center">
      <Show when={props.icon}>
        <div class="flex h-8 w-8 items-center justify-center lg:h-10 lg:w-10 rounded-full bg-secondary opacity-50">
          {props.icon}
        </div>
      </Show>
      <span class="block truncate font-semibold text-sm text-secondary">{props.title}</span>
      <span class="block truncate text-sm">{props.children}</span>
    </div>
  );
};

export default ClientDetail;


----- src/screens/Dashboard/pages/Other/Currencies/index.tsx -----
import { getCurrencies, getModelCount } from "@/bindings";
import { useI18n } from "@/i18n";
import Table from "@/screens/Dashboard/components/Table";
import { FiPlus } from "solid-icons/fi";
import type { Component } from "solid-js";
import { useNavigate } from "@solidjs/router";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import Container from "@/screens/Dashboard/components/Container";

const Currencies: Component = () => {
  const [t] = useI18n();
  const navigate = useNavigate();

  return (
    <Container>
      <PageHeader
        title={[t("sidebar.section.other"), t("sidebar.button.currencies")]}
        actionElements={[
          <HeaderButton onClick={() => navigate("new")} buttonType="primary">
            <FiPlus class="stroke-2" />
          </HeaderButton>,
        ]}
      />
      <Table
        columns={[
          { field: "name", header: "Name" },
          { field: "code", header: "Code" },
          { field: "rate", header: "Rate" },
        ]}
        totalItems={getModelCount("Currency")}
        loadPage={getCurrencies}
        onClickRow={(item) => navigate(item.id)}
      />
    </Container>
  );
};

export default Currencies;


----- src/screens/Dashboard/pages/Other/Currencies/ManageCurrency.tsx -----
import { type Currency, createCurrency, updateCurrency, deleteCurrency, getCurrency } from "@/bindings";
import { useI18n } from "@/i18n";
import { FiTrash } from "solid-icons/fi";
import type { Component } from "solid-js";
import { useNavigate, useParams } from "@solidjs/router";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import Container from "@/screens/Dashboard/components/Container";
import { createForm } from "@tanstack/solid-form";
import Input from "@/shared/components/Form/Input";
import { zodValidator } from "@tanstack/zod-form-adapter";
import { z } from "zod";
import Section from "@/shared/components/Form/Section";
import toast from "solid-toast";
import { Show, onMount } from "solid-js";
import Form from "@/shared/components/Form";

const ManageCurrency: Component = () => {
  const params = useParams<{ readonly id?: string }>();
  const [t] = useI18n();
  const navigate = useNavigate();
  const form = createForm(() => ({
    defaultValues: {
      id: "",
      name: "",
      code: "",
      rate: 1,
    } as Currency,
    validatorAdapter: zodValidator,
    onSubmitInvalid: (e) => {
      console.log("invalid", e.formApi.state.errors);
    },
    onSubmit: async (currency) => {
      console.log(currency.value);
      try {
        if (currency.value.id) {
          await updateCurrency(currency.value.id, currency.value);
          toast.success(t("pages.other.currencies.form.toast.updated"));
        } else {
          await createCurrency(currency.value);
          toast.success(t("pages.other.currencies.form.toast.saved"));
        }
        navigate("/dashboard/other/currencies");
      } catch (e) {
        toast.error(t("pages.other.currencies.form.toast.saveFailed"));
        console.error(e);
      }
    },
  }));

  onMount(async () => {
    if (params.id) {
      const currency = await getCurrency(params.id);
      form.update({ ...form.options, defaultValues: currency });
      console.log(form.state.values);
    }
  });

  return (
    <Container>
      <PageHeader
        title={[
          t("sidebar.section.other"),
          t("sidebar.button.currencies"),
          params.id ? params.id : t("pageHeader.new"),
        ]}
        actionElements={[
          <HeaderButton onClick={() => form.handleSubmit()} buttonType="primary">
            {t("pages.other.currencies.form.save")}
          </HeaderButton>,
          <Show when={params.id}>
            <HeaderButton
              onClick={async () => {
                try {
                  await deleteCurrency(form.state.values.id);
                  toast.success(t("pages.other.currencies.form.toast.deleted"));
                  navigate("/dashboard/other/currencies");
                } catch (e) {
                  toast.error(e as string);
                }
              }}
              buttonType="secondary"
            >
              <FiTrash />
            </HeaderButton>
          </Show>,
        ]}
      />
      <Form>
        <Section title={t("pages.other.currencies.form.sections.information")}>
          <form.Field name="name" validators={{ onChange: z.string().min(2).max(100), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.currencies.form.name")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="code" validators={{ onChange: z.string().min(2).max(10), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                type="text"
                label={t("pages.other.currencies.form.code")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(data)}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
          <form.Field name="rate" validators={{ onChange: z.number().min(0), onChangeAsyncDebounceMs: 500 }}>
            {(field) => (
              <Input
                float
                type="number"
                label={t("pages.other.currencies.form.rate")}
                defaultValue={field().state.value}
                onChange={(data) => field().handleChange(Number(data))}
                errors={field().state.meta.touchedErrors}
              />
            )}
          </form.Field>
        </Section>
      </Form>
    </Container>
  );
};

export default ManageCurrency;


----- src/screens/Dashboard/pages/Other/Templates/index.tsx -----
import { getTemplates, getModelCount } from "@/bindings";
import { useI18n } from "@/i18n";
import Table from "@/screens/Dashboard/components/Table";
import { FiPlus } from "solid-icons/fi";
import type { Component } from "solid-js";
import { useNavigate } from "@solidjs/router";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import Container from "@/screens/Dashboard/components/Container";
import StatusIcon from "@/screens/Dashboard/components/StatusIcon";

const Templates: Component = () => {
  const [t] = useI18n();
  const navigate = useNavigate();

  return (
    <Container>
      <PageHeader
        title={[t("sidebar.section.other"), t("sidebar.button.templates")]}
        actionElements={[
          <HeaderButton onClick={() => navigate("new")} buttonType="primary">
            <FiPlus class="stroke-2" />
          </HeaderButton>,
        ]}
      />
      <Table
        columns={[
          { field: "id", header: "ID" },
          { field: "name", header: "Name" },
          {
            field: "templateType",
            header: "Type",
            component: (item) => <StatusIcon>{item.templateType as string}</StatusIcon>,
          },
        ]}
        totalItems={getModelCount("Template")}
        loadPage={async (indices) => await getTemplates(indices)}
        onClickRow={(item) => navigate(`${item.id}`)}
      />
    </Container>
  );
};

export default Templates;


----- src/screens/Dashboard/pages/Other/Templates/ManageTemplate.tsx -----
import {
  type Accessor,
  type Setter,
  createEffect,
  createSignal,
  on,
  onMount,
  type Component,
  Show,
  type ParentComponent,
} from "solid-js";
import PageHeader from "@/screens/Dashboard/components/PageHeader";
import { useI18n } from "@/i18n";
import { useNavigate, useParams } from "@solidjs/router";
import HeaderButton from "@/screens/Dashboard/components/PageHeader/HeaderButton";
import { createCodeMirror, createEditorControlledValue } from "solid-codemirror";
import { highlightActiveLineGutter, lineNumbers } from "@codemirror/view";
import type { Extension } from "@codemirror/state";
import { liquid } from "@codemirror/lang-liquid";
import { material } from "@uiw/codemirror-theme-material";
import { createTemplate, deleteTemplate, getTemplate, updateTemplate } from "@/bindings";
import toast from "solid-toast";
import { FiList, FiSettings, FiTrash } from "solid-icons/fi";
import TemplateHint from "@/screens/Dashboard/components/TemplateHint";
import { createForm } from "@tanstack/solid-form";
import Form from "@/shared/components/Form";
import Section from "@/shared/components/Form/Section";
import Input from "@/shared/components/Form/Input";
import Dropdown from "@/shared/components/Form/Dropdown";

const ManageTemplate: Component = () => {
  const params = useParams<{ readonly id?: string }>();
  const navigate = useNavigate();
  const [t] = useI18n();
  const [showSettings, setShowSettings] = createSignal(false);
  const [showHints, setShowHints] = createSignal(false);

  const [templateCode, setTemplateCode] = createSignal(`
    <div class="bg-white p-8 rounded shadow">
      <h1 class="text-2xl font-bold mb-4">Invoice</h1>
      
      <div class="mb-8"> 
        <p class="text-gray-600">Invoice Number: {{ number }}</p>
        <p class="text-gray-600">Issue Date: {{ issueDate }}</p>
        <p class="text-gray-600">Due Date: {{ dueDate }}</p>
      </div>
        
      <div class="grid grid-cols-2 gap-8 mb-8">
        <div>
          <h2 class="text-xl font-bold mb-2">Client Details</h2>
          <p>{{ client.name }}</p>
          <p>CIN: {{ client.cin }}</p>
          <p>VAT ID: {{ client.vatId }}</p>
          <p>{{ client.address }}</p>
          <p>{{ client.city }}, {{ client.zip }}</p>
          <p>Email: {{ client.email }}</p>
          <p>Phone: {{ client.phone }}</p>
          <p>Bank Account: {{ client.bankAccount }}</p>
          <p>IBAN: {{ client.IBAN }}</p>
        </div>
        
        <div>
          <h2 class="text-xl font-bold mb-2">Company Details</h2>
          <p>{{ company.name }}</p>
          <p>CIN: {{ company.cin }}</p>
          <p>VAT ID: {{ company.vatId }}</p>
          <p>{{ company.address }}</p>
          <p>{{ company.city }}, {{ company.zip }}</p>
          <p>Email: {{ company.email }}</p>
          <p>Phone: {{ company.phone }}</p>
          <p>Bank Account: {{ company.bankAccount }}</p>
          <p>IBAN: {{ company.IBAN }}</p>
        </div>
      </div>
      
      <table class="w-full mb-8">
        <thead>
          <tr class="bg-gray-100">
            <th class="px-4 py-2">Description</th>
            <th class="px-4 py-2">Quantity</th>
            <th class="px-4 py-2">Price</th>
            <th class="px-4 py-2">Total</th>
          </tr>
        </thead>
        <tbody>
          {% for item in items %}
            <tr>
              <td class="border px-4 py-2">{{ item.description }}</td>
              <td class="border px-4 py-2">{{ item.quantity }}</td>
              <td class="border px-4 py-2">{{ item.price }} {{ currency.code }}</td>
              <td class="border px-4 py-2">{{ item.quantity | times: item.price }} {{ currency.code }}</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
      
      <div class="text-right">
        <p class="text-xl font-bold">Total: {{ items | map: 'price' | sum }} {{ currency.code }}</p>
      </div>
    </div>
  `);

  const form = createForm<{
    name: string;
    templateType: "INVOICE" | "PROFORMA" | "RECEIVE";
  }>(() => ({
    defaultValues: {
      name: "",
      templateType: "INVOICE",
    },
    onSubmitInvalid: (e) => {
      console.log("invalid", e.formApi.state.errors);
    },

    onSubmit: async (template) => {
      try {
        if (params.id) {
          await updateTemplate(Number.parseInt(params.id), {
            ...template.value,
            html: templateCode(),
          });
          toast.success(t("pages.other.templates.toast.updated"));
        } else {
          await createTemplate({
            ...template.value,
            html: templateCode(),
          });
          toast.success(t("pages.other.templates.toast.saved"));
        }
        navigate("/dashboard/other/templates");
      } catch (e) {
        toast.error(t("pages.other.templates.toast.saveFailed"));
        console.error(e);
      }
    },
  }));

  onMount(async () => {
    if (params.id) {
      const data = await getTemplate(Number(params.id));
      setTemplateCode(data.html);
      form.update({
        ...form.options,
        defaultValues: data,
      });
    }
  });

  return (
    <>
      <PageHeader
        title={[t("sidebar.section.other"), t("sidebar.button.templates"), params.id ? params.id : t("pageHeader.new")]}
        actionElements={[
          <HeaderButton onClick={form.handleSubmit} buttonType="primary">
            {t("pages.other.templates.save")}
          </HeaderButton>,
          <HeaderButton buttonType="secondary" onClick={() => setShowSettings(!showSettings())}>
            <FiSettings />
          </HeaderButton>,
          <HeaderButton buttonType="secondary" onClick={() => setShowHints(!showHints())}>
            <FiList />
          </HeaderButton>,
          <Show when={params.id}>
            <HeaderButton
              buttonType="secondary"
              onClick={async () => {
                try {
                  await deleteTemplate(Number(params.id));
                  toast.success(t("pages.other.templates.toast.deleted"));
                  navigate("/dashboard/other/templates");
                } catch (e) {
                  toast.error(e as string);
                }
              }}
            >
              <FiTrash />
            </HeaderButton>
          </Show>,
        ]}
      />

      <div class="relative h-full">
        <Editor code={templateCode} onValueChange={setTemplateCode} />
        <SidePopup show={showHints()} onClickOutside={() => setShowHints(false)}>
          <h2 class="text-lg font-bold mb-4">{t("pages.other.templates.dataHints")}</h2>
          <TemplateHint />
        </SidePopup>
        <SidePopup show={showSettings()} onClickOutside={() => setShowSettings(false)}>
          <Form>
            <Section title={t("pages.other.templates.sections.information")} columns={1}>
              <form.Field name="name">
                {(field) => (
                  <Input
                    label={t("pages.other.templates.name")}
                    type="text"
                    placeholder={t("pages.other.templates.namePlaceholder")}
                    defaultValue={field().state.value}
                    onChange={(e) => field().handleChange(e)}
                  />
                )}
              </form.Field>
              <form.Field name="templateType">
                {(field) => (
                  <Dropdown
                    label={t("pages.other.templates.templateType")}
                    defaultValueId={form.state.values.templateType}
                    data={[
                      { id: "INVOICE", label: t("pages.other.templates.templateTypes.invoice") },
                      { id: "PROFORMA", label: t("pages.other.templates.templateTypes.proforma") },
                      { id: "RECEIVE", label: t("pages.other.templates.templateTypes.receive") },
                    ]}
                    onSelect={(data) => field().handleChange(data.id as "INVOICE" | "PROFORMA" | "RECEIVE")}
                  />
                )}
              </form.Field>
            </Section>
          </Form>
        </SidePopup>
      </div>
    </>
  );
};

export default ManageTemplate;

const SidePopup: ParentComponent<{ show: boolean; onClickOutside: () => void }> = (props) => {
  return (
    <Show when={props.show}>
      <div class="fixed top-0 left-0 w-full h-full grid grid-cols-6 grid-rows-1 justify-between z-999">
        <div class="bg-black bg-opacity-20 w-full col-span-4" onClick={props.onClickOutside} />
        <div class="bg-primary col-span-2 p-4 overflow-scroll pt-44px">{props.children}</div>
      </div>
    </Show>
  );
};

const Editor: Component<{ onValueChange: Setter<string>; code: Accessor<string> }> = (props) => {
  const {
    editorView,
    ref: editorRef,
    createExtension,
  } = createCodeMirror({
    /**
     * The initial value of the editor
     */
    value: props.code(),
    /**
     * Fired whenever the editor code value changes.
     */
    onValueChange: (value) => {
      props.onValueChange(value);
    },
  });
  const extensions = (): Extension => {
    return [lineNumbers(), highlightActiveLineGutter(), liquid(), material];
  };

  createEditorControlledValue(editorView, props.code);

  createEffect(on(extensions, (extensions) => reconfigure(extensions)));

  const reconfigure = createExtension(extensions());
  return (
    <div
      class="h-full w-full"
      ref={(el) => {
        onMount(() => {
          editorRef(el);
        });
      }}
    />
  );
};


----- src/i18n/index.ts -----
import { createContextProvider } from "@solid-primitives/context";
import * as i18n from "@solid-primitives/i18n";
import { makePersisted } from "@solid-primitives/storage";
import { createSignal } from "solid-js";
import { LANG } from "@/constants";
import dict, { type Dict } from "./dict";

export const [locale, setLocale] = makePersisted(
  createSignal<LANG>(Reflect.has(dict, navigator.language) ? (navigator.language as LANG) : LANG.EN),
  {
    name: "lang",
    storage: localStorage,
  },
);

export const [I18nProvider, useMaybeI18n] = createContextProvider<[i18n.Translator<Dict>], { locale: LANG }>(
  (props) => [i18n.translator(() => i18n.flatten(dict[props.locale]), i18n.resolveTemplate)],
);

// biome-ignore lint/style/noNonNullAssertion: burger
export const useI18n = () => useMaybeI18n()!;


----- src/i18n/dict/en.json -----
{
  "hello": "Hello",
  "world": "World",
  "setup": {
    "welcome": "Welcome to the app",
    "get_started": "Get started",
    "continue": "Continue",
    "finalize": "Finalize",
    "step1": {
      "select_language": "Select your language",
      "select_currency": "Select your currency",
      "improve": "Help us improve"
    },
    "step2": {
      "create_company": "Let's create your company",
      "company_name": "Company name",
      "CIN": "CIN",
      "vatID": "VAT ID",
      "street": "Street",
      "city": "City",
      "zip": "ZIP",
      "email": "Email",
      "phone": "Phone",

      "sections": {
        "details": "Details",
        "bank": "Bank details",
        "contact": "Contact details"
      },
      "account": "Account number",
      "iban": "IBAN",
      "help": {
        "retrieve_by_cin": "After entering your CIN, we will try to retrieve your company information from the government database."
      }
    },
    "error_creating_ompany": "Error creating company",
    "company_created": "Company created"
  },
  "table": {
    "all": "All"
  },
  "pageHeader": {
    "search": "Search",
    "new": "New Entry"
  },
  "pages": {
    "other": {
      "templates": {
        "save": "Save",
        "dataHints": "Data Hints",
        "sections": {
          "information": "Template Information"
        },
        "name": "Name",
        "namePlaceholder": "Invoice",
        "templateType": "Template Type",
        "templateTypes": {
          "invoice": "Invoice",
          "proforma": "Proforma Invoice",
          "receive": "Received Invoice"
        },
        "toast": {
          "updated": "Template updated",
          "saved": "Template saved",
          "saveFailed": "Failed to save template",
          "deleted": "Template deleted"
        }
      },

      "currencies": {
        "form": {
          "save": "Save",
          "sections": {
            "information": "Currency Information"
          },
          "name": "Name",
          "code": "Code",
          "rate": "Rate (from EURO)",
          "toast": {
            "updated": "Currency updated",
            "saved": "Currency saved",
            "saveFailed": "Failed to save currency",
            "deleted": "Currency deleted"
          }
        }
      },
      "clients": {
        "form": {
          "save": "Save",
          "sections": {
            "information": "Client Information",
            "address": "Address",
            "bank": "Banking Details"
          },
          "bankAccount": "Bank Account",
          "bankIban": "IBAN",
          "name": "Name",
          "email": "Email",
          "clientType": "Client Type",
          "clientTypes": {
            "both": "Both",
            "supplier": "Supplier",
            "customer": "Customer"
          },
          "cin": "CIN",
          "vatId": "VAT ID",
          "address": "Street Address",
          "city": "City",
          "zip": "Zip Code",
          "phone": "Phone Number",
          "toast": {
            "updated": "Client updated",
            "saved": "Client saved",
            "saveFailed": "Failed to save client",
            "deleted": "Client deleted"
          }
        }
      }
    },
    "sales": {
      "document": {
        "title": {
          "invoice": "Invoice",
          "proforma": "Proforma",
          "receive": "Received Invoice"
        },
        "new": "New",
        "delete": "Delete",
        "download": "Download",
        "information": "Information",
        "number": "Number",
        "numberRequired": "Number is required",
        "client": "Client",
        "clientRequired": "Client is required",
        "template": "Template",
        "templateRequired": "Template is required",
        "currency": "Currency",
        "currencyRequired": "Currency is required",
        "status": {
          "label": "Status",
          "draft": "Draft",
          "sent": "Sent",
          "paid": "Paid",
          "cancelled": "Cancelled",
          "overdue": "Overdue"
        },
        "dates": "Dates",
        "issueDate": "Issue Date",
        "dueDate": "Due Date",
        "dueDateError": "Due date must be today or later",
        "items": "Items",
        "itemDescription": "Description for item {{number}}",
        "itemQuantity": "Quantity for item {{number}}",
        "itemPrice": "Price for item {{number}}",
        "addItem": "Add item",
        "toast": {
          "updated": "Document updated",
          "saved": "Document saved",
          "deleted": "Document deleted",
          "saveFailed": "Failed to save document"
        }
      }
    }
  },
  "sidebar": {
    "button": {
      "overview": "Overview",
      "invoices": "Invoices",
      "proformas": "Proformas",
      "clients": "Clients",
      "expenses": "Expenses",
      "receivedInvoices": "Received Invoices",
      "reports": "Reports",
      "settings": "Settings",
      "templates": "Templates",
      "schedules": "Schedules",
      "currencies": "Currencies",

      "company": {
        "create": "Create company"
      }
    },
    "section": {
      "sales": "Purchase & Sales",
      "purchase": "",
      "reports": "Reports",
      "other": "Other"
    }
  },
  "statbox": {
    "lastMonth": "Last month"
  },
  "overview": {
    "chart": {
      "sales": "Sales",
      "expenses": "Expenses",

      "sentInvoices": "Sent invoices",
      "receivedInvoices": "Received invoices"
    },
    "months": {
      "january": "January",
      "february": "February",
      "march": "March",
      "april": "April",
      "may": "May",
      "june": "June",
      "july": "July",
      "august": "August",
      "september": "September",
      "october": "October",
      "november": "November",
      "december": "December"
    },

    "stats": {
      "sales": "Sales",
      "expenses": "Expenses"
    }
  },

  "hints": {
    "collapsible": {
      "object": "Object",
      "array": "Array"
    },
    "number": "Invoice number",
    "client": {
      "name": "Client name",
      "cin": "Client identification number",
      "vatId": "VAT identification number",
      "address": "Client address",
      "city": "Client city",
      "zip": "Client zip code",
      "email": "Client email",
      "phone": "Client phone number",
      "bankAccount": "Bank account number",
      "iban": "IBAN"
    },
    "company": {
      "name": "Company name",
      "cin": "Company identification number",
      "vatId": "VAT identification number",
      "address": "Company address",
      "city": "Company city",
      "zip": "Company zip code",
      "email": "Company email",
      "phone": "Company phone number",
      "bankAccount": "Bank account number",
      "iban": "IBAN"
    },
    "currency": {
      "name": "Currency name",
      "code": "Currency code"
    },
    "issueDate": "Issue date",
    "dueDate": "Due date",
    "items": {
      "description": "Item description",
      "quantity": "Item quantity",
      "price": "Item price"
    }
  },
  "settings": {
    "general": {
      "title": "General",
      "create_company": "Let's create your company",
      "company_name": "Company name",
      "CIN": "CIN",
      "vatID": "VAT ID",
      "street": "Street",
      "city": "City",
      "zip": "ZIP",
      "email": "Email",
      "phone": "Phone",

      "sections": {
        "details": "Details",
        "bank": "Bank details",
        "contact": "Contact details"
      },
      "account": "Account number",
      "iban": "IBAN",
      "toast": {
        "updated": "Company updated",
        "updateFailed": "Failed to save company"
      }
    },
    "document": {
      "title": "Documents",
      "sections": {
        "defaults": "Defaults",
        "prefixesCounters": "Prefixes & Counters"
      },
      "template": "Template",
      "currency": "Currency",
      "invoicePrefix": "Invoice Prefix",
      "invoiceCounter": "Invoice Counter",
      "proformaPrefix": "Proforma Prefix",
      "proformaCounter": "Proforma Counter",
      "receivePrefix": "Receive Prefix",
      "receiveCounter": "Receive Counter",
      "save": "Save",
      "toast": {
        "saved": "Settings saved",
        "saveFailed": "Failed to save settings"
      }
    },
    "language": "Language"
  },
  "invoices": {
    "title": "Faktury"
  },
  "components": {
    "search": "Search",
    "dropdownSelect": "Select an item"
  },
  "other": {
    "save": "Save"
  }
}


----- src/i18n/dict/index.ts -----
import type { Flatten } from "@solid-primitives/i18n";
import { LANG } from "@/constants";
import en from "./en.json";
import cs from "./cs.json";

export type Dict = Flatten<typeof en>;

export default {
  [LANG.EN]: en,
  [LANG.CS]: cs,
};


----- src/i18n/dict/cs.json -----
{
  "setup": {
    "welcome": "Vítejte",
    "get_started": "Začít",
    "continue": "Pokračovat",
    "finalize": "Dokončit",
    "step1": {
      "select_language": "Vyberte jazyk",
      "select_currency": "Vyberte měnu",
      "improve": "Pomozte nám zlepšit"
    },
    "step2": {
      "create_company": "Pojďme vytvořit firmu",
      "company_name": "Název firmy / podnikatele",
      "CIN": "IČO",
      "vatID": "DIČ",
      "street": "Ulice",
      "city": "Město",
      "zip": "PSČ",
      "email": "Email",
      "phone": "Telefon",
      "sections": {
        "details": "Detaily",
        "bank": "Bankovní účet",
        "contact": "Kontakt"
      },
      "account": "Číslo účtu",
      "iban": "IBAN",
      "help": {
        "retrieve_by_cin": "Po zadání správného IČA se načte zbytek údajů automaticky"
      }
    },
    "error_creating_ompany": "Při vytváření firmy došlo k chybě. Zkuste to prosím znovu.",
    "company_created": "Firma byla úspěšně vytvořena"
  },
  "table": {
    "all": "Vše"
  },
  "pageHeader": {
    "search": "Hledat",
    "new": "Nový záznam"
  },
  "sidebar": {
    "button": {
      "overview": "Přehled",
      "invoices": "Faktury vydané",
      "proformas": "Zálohové faktury",
      "clients": "Klienti",
      "expenses": "Výdaje",
      "receivedInvoices": "Přijaté faktury",
      "reports": "Reporty",
      "settings": "Nastavení",
      "templates": "Šablony",
      "schedules": "Opakované platby",
      "currencies": "Měny",
      "company": {
        "create": "Vytvořit firmu"
      }
    },
    "section": {
      "sales": "Nákup & Prodej",
      "reports": "Reporty",
      "other": "Ostatní"
    }
  },
  "statbox": {
    "lastMonth": "Minulý měsíc"
  },
  "overview": {
    "chart": {
      "sales": "Prodej",
      "expenses": "Výdaje",

      "sentInvoices": "Odeslané faktury",
      "receivedInvoices": "Přijaté faktury"
    },
    "months": {
      "january": "Leden",
      "february": "Únor",
      "march": "Březen",
      "april": "Duben",
      "may": "Květen",
      "june": "Červen",
      "july": "Červenec",
      "august": "Srpen",
      "september": "Září",
      "october": "Říjen",
      "november": "Listopad",
      "december": "Prosinec"
    },
    "stats": {
      "sales": "Prodej",
      "expenses": "Výdaje"
    }
  },

  "pages": {
    "other": {
      "templates": {
        "save": "Uložit",
        "dataHints": "Nápověda dat",
        "sections": {
          "information": "Informace o šabloně"
        },
        "name": "Název",
        "namePlaceholder": "Faktura",
        "templateType": "Typ šablony",
        "templateTypes": {
          "invoice": "Faktura",
          "proforma": "Zálohová faktura",
          "receive": "Přijatá faktura"
        },
        "toast": {
          "updated": "Šablona aktualizována",
          "saved": "Šablona uložena",
          "saveFailed": "Nepodařilo se uložit šablonu",
          "deleted": "Šablona smazána"
        }
      },
      "currencies": {
        "form": {
          "save": "Uložit",
          "sections": {
            "information": "Informace o měně"
          },
          "name": "Název",
          "code": "Kód",
          "rate": "Kurz (z EURO)",
          "toast": {
            "updated": "Měna aktualizována",
            "saved": "Měna uložena",
            "saveFailed": "Nepodařilo se uložit měnu",
            "deleted": "Měna smazána"
          }
        }
      },
      "clients": {
        "form": {
          "save": "Uložit",
          "sections": {
            "information": "Informace o klientovi",
            "address": "Adresa",
            "bank": "Bankovní účet"
          },
          "bankAccount": "Číslo účtu",
          "bankIban": "IBAN",
          "name": "Jméno",
          "email": "Email",
          "clientType": "Typ klienta",
          "clientTypes": {
            "both": "Oba",
            "supplier": "Dodavatel",
            "customer": "Zákazník"
          },
          "cin": "IČO",
          "vatId": "DIČ",
          "address": "Ulice",
          "city": "Město",
          "zip": "PSČ",
          "phone": "Telefonní číslo",
          "toast": {
            "updated": "Klient aktualizován",
            "saved": "Klient uložen",
            "saveFailed": "Nepodařilo se uložit klienta",
            "deleted": "Klient smazán"
          }
        }
      }
    },
    "sales": {
      "document": {
        "title": {
          "invoice": "Faktura",
          "proforma": "Zálohová faktura",
          "receive": "Přijatá faktura"
        },
        "new": "Nový",
        "delete": "Smazat",
        "download": "Stáhnout",
        "information": "Informace",
        "number": "Číslo",
        "numberRequired": "Číslo je povinné",
        "client": "Klient",
        "clientRequired": "Klient je povinný",
        "template": "Šablona",
        "templateRequired": "Šablona je povinná",
        "currency": "Měna",
        "currencyRequired": "Měna je povinná",
        "status": {
          "label": "Stav",
          "draft": "Koncept",
          "sent": "Odesláno",
          "paid": "Zaplaceno",
          "cancelled": "Zrušeno",
          "overdue": "Po splatnosti"
        },
        "dates": "Data",
        "issueDate": "Datum vystavení",
        "dueDate": "Datum splatnosti",
        "dueDateError": "Datum splatnosti musí být dnes nebo později",
        "items": "Položky",
        "itemDescription": "Popis položky {{number}}",
        "itemQuantity": "Množství položky {{number}}",
        "itemPrice": "Cena položky {{number}}",
        "addItem": "Přidat položku",
        "toast": {
          "updated": "Dokument byl úspěšně aktualizovaný",
          "saved": "Dokument byl uložený",
          "deleted": "Bokument byl smazán",
          "saveFailed": "Nepodařilo se uložit dokument"
        }
      }
    }
  },

  "hints": {
    "collapsible": {
      "object": "Objekt",
      "array": "Pole"
    },
    "number": "Číslo faktury",
    "client": {
      "name": "Jméno klienta",
      "cin": "IČO klienta",
      "vatId": "DIČ klienta",
      "address": "Adresa klienta",
      "city": "Město klienta",
      "zip": "PSČ klienta",
      "email": "E-mail klienta",
      "phone": "Telefonní číslo klienta",
      "bankAccount": "Bankovní účet klienta",
      "iban": "IBAN klienta"
    },
    "company": {
      "name": "Název společnosti",
      "cin": "IČO společnosti",
      "vatId": "DIČ společnosti",
      "address": "Adresa společnosti",
      "city": "Město společnosti",
      "zip": "PSČ společnosti",
      "email": "E-mail společnosti",
      "phone": "Telefonní číslo společnosti",
      "bankAccount": "Bankovní účet společnosti",
      "iban": "IBAN společnosti"
    },
    "currency": {
      "name": "Název měny",
      "code": "Kód měny"
    },
    "issueDate": "Datum vystavení",
    "dueDate": "Datum splatnosti",
    "items": {
      "description": "Popis položky",
      "quantity": "Množství položky",
      "price": "Cena položky"
    }
  },

  "settings": {
    "general": {
      "title": "Obecné",
      "company_name": "Název firmy / podnikatele",
      "CIN": "IČO",
      "vatID": "DIČ",
      "street": "Ulice",
      "city": "Město",
      "zip": "PSČ",
      "email": "Email",
      "phone": "Telefon",
      "sections": {
        "details": "Detaily",
        "bank": "Bankovní účet",
        "contact": "Kontakt"
      },
      "toas": {
        "updated": "Firma byla úspěšně aktualizována",
        "updateFailed": "Nepodařilo se uložit firmu"
      },
      "account": "Číslo účtu",
      "iban": "IBAN"
    },
    "document": {
      "title": "Dokumenty",
      "sections": {
        "defaults": "Výchozí hodnoty",
        "prefixesCounters": "Předpony a počítadla"
      },
      "template": "Šablona",
      "currency": "Měna",
      "invoicePrefix": "Předpona faktury",
      "invoiceCounter": "Počítadlo faktur",
      "proformaPrefix": "Předpona zálohové faktury",
      "proformaCounter": "Počítadlo zálohových faktur",
      "receivePrefix": "Předpona přijaté faktury",
      "receiveCounter": "Počítadlo přijatých faktur",
      "save": "Uložit",
      "toast": {
        "saved": "Nastavení uloženo",
        "saveFailed": "Nepodařilo se uložit nastavení"
      }
    },
    "language": "Jazyk"
  },
  "invoices": {
    "title": "Faktury"
  },
  "components": {
    "search": "Hledat",
    "dropdownSelect": "Vyberte z možností"
  },
  "other": {
    "save": "Uložit"
  }
}


----- src/store/index.tsx -----
import { createContext, createSignal, type ParentComponent, useContext } from "solid-js";
import { CompanyService } from "./services/CompanyService";
import { SettingsService } from "./services/SettingsService";
import { StateService } from "./services/stateService";

export type RootState = {
  companyService: ReturnType<typeof CompanyService>;
  settingsService: ReturnType<typeof SettingsService>;
  stateService: ReturnType<typeof StateService>;
};

const createRootState = (): RootState => {
  const [companyService] = createSignal(CompanyService());
  const [settingsService] = createSignal(SettingsService());
  const [stateService] = createSignal(StateService());

  return {
    companyService: companyService(),
    stateService: stateService(),
    settingsService: settingsService(),
  };
};

const StoreContext = createContext<RootState>();

export const useSelector = <T,>(selector: (state: RootState) => T): T => {
  const store = useContext(StoreContext);
  if (!store) {
    throw new Error("useSelector must be used within a StoreProvider");
  }
  return selector(store);
};

export const StoreProvider: ParentComponent = (props) => {
  const store = createRootState();

  return <StoreContext.Provider value={store}>{props.children}</StoreContext.Provider>;
};


----- src/store/services/CompanyService.ts -----
import { getCompany, type Company } from "@/bindings";
import { createStore } from "solid-js/store";

const companyStore = createStore<Company>({} as Company);

export const CompanyService = () => {
  const [company, setCompany] = companyStore;

  const updateCompany = async () => {
    setCompany(await getCompany());
  };

  return { company, updateCompany };
};


----- src/store/services/stateService.ts -----
import { onMount } from "solid-js";
import { type StoreSetter, createStore } from "solid-js/store";
import { type Platform, platform } from "@tauri-apps/plugin-os";

export interface StateService {
  companyId: number;
  platform: Platform;
}

export const stateStore = createStore<StateService>({} as StateService);

export const StateService = () => {
  const [state, setState] = stateStore;

  onMount(async () => {
    const stateString = localStorage.getItem("state");

    if (!stateString) {
      setState({ companyId: 0, platform: await platform() });
    } else {
      const parsedState = JSON.parse(stateString) as unknown as StateService;
      setState({ ...parsedState, platform: await platform() });
    }
  });

  const updateState = (value: StoreSetter<StateService>) => {
    setState((prevState) => {
      const newState = typeof value === "function" ? value(prevState, []) : value;
      return newState;
    });

    localStorage.setItem("state", JSON.stringify(state));
  };

  return { state, updateState };
};


----- src/store/services/SettingsService.ts -----
import { getSettings, type Settings } from "@/bindings";
import { createStore } from "solid-js/store";

const settingsStore = createStore<Settings>({} as Settings);

export const SettingsService = () => {
  const [settings, setSettings] = settingsStore;

  const updateSettings = async () => {
    setSettings(await getSettings());
  };

  return { settings, updateSettings };
};


